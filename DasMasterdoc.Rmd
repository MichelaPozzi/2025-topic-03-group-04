---
title: "MasterDoc"
author: "Nora Otic"
date: "2025-06-19"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r cars}
summary(cars)
```

## Including Plots

You can also embed plots, for example:

```{r pressure, echo=FALSE}
plot(pressure)
```

Note that the `echo = FALSE` parameter was added to the code chunk to prevent printing of the R code that generated the plot.

######Part 1
###Reproducability
###Normalization
###Batch-effect

```{r}
#load dataset
url <- "https://hub.dkfz.de/s/QT3BfRperQqMxPF/download/RDeeP_A549_NS.csv.zip"


#Create a temporary file and download the ZIP
temp_file <- tempfile()
download.file(url, temp_file)
zip_contents <- unzip(temp_file, list = TRUE)
print(zip_contents)

csv_file <- unzip(temp_file, files = zip_contents$Name[1], exdir = tempdir())
A549_NS <- read.csv(csv_file, sep = ";")
View(A549_NS)
```

```{r}
#data exploration
View(A549_NS)

#number of rows and columns
nrow(A549_NS)
ncol(A549_NS)

#type of data (überprüft die class der Spalten -> alle Eintrage haben zwangsweise dieselbe class)
sum(sapply(A549_NS, is.numeric))

#finding NAs
sum(is.na(A549_NS))
```

##Data cleanup##

```{r}
# Alle Spaltennamen abrufen
col_names <- colnames(A549_NS)

# Spalten für Ctrl und RNase erkennen (inkl. Protein_Name behalten)
ctrl_cols <- c("Protein_Name", grep("Ctrl", col_names, value = TRUE))
rnase_cols <- c("Protein_Name", grep("RNase", col_names, value = TRUE))

# Dataframes erstellen
df_ctrl <- A549_NS[, ctrl_cols, drop = FALSE]
df_rnase <- A549_NS[, rnase_cols, drop = FALSE]

# Vorschau anzeigen
head(df_ctrl)
head(df_rnase)


```

####Reproducibility####

```{r}
#Reproducabilty der Control Messung
ctrl_correlations <- data.frame(
  fraction = character(),
  ctrl1_vs_ctrl2 = numeric(),
  ctrl1_vs_ctrl3 = numeric(),
  ctrl2_vs_ctrl3 = numeric(),
  stringsAsFactors = FALSE
)

# Schleife über alle 25 Fraktionen
for (i in 0:24) {
  start_col <- 2 + i * 3 
  end_col <- start_col + 2
  ctrl_data <- df_ctrl[, start_col:end_col]
  colnames(ctrl_data) <- c("ctrl1", "ctrl2", "ctrl3")
  cor_matrix <- cor(ctrl_data, use = "pairwise.complete.obs", method = "spearman")
  ctrl_correlations <- rbind(ctrl_correlations, data.frame(
    fraction = paste0("fraction", i + 1),
    ctrl1_vs_ctrl2 = cor_matrix["ctrl1", "ctrl2"],
    ctrl1_vs_ctrl3 = cor_matrix["ctrl1", "ctrl3"],
    ctrl2_vs_ctrl3 = cor_matrix["ctrl2", "ctrl3"]
  ))
}

# Ergebnis ansehen
View(ctrl_correlations)
plot(ctrl_correlations) 
```

```{r}
#Reproducabilty der RNase Messungen

rnase_correlations <- data.frame(
  fraction = character(),
  rnase1_vs_rnase2 = numeric(),
  rnase1_vs_rnase3 = numeric(),
  rnase2_vs_rnase3 = numeric(),
  stringsAsFactors = FALSE
)

# Schleife über alle 25 Fraktionen
for (i in 0:24) {
  start_col <- 2 + i * 3 
  end_col <- start_col + 2
  rnase_data <- df_rnase[, start_col:end_col]
  colnames(rnase_data) <- c("rnase1", "rnase2", "rnase3")
  cor_matrix <- cor(rnase_data, use = "pairwise.complete.obs", method = "spearman")
  rnase_correlations <- rbind(rnase_correlations, data.frame(
    fraction = paste0("fraction", i + 1),
    rnase1_vs_rnase2 = cor_matrix["rnase1", "rnase2"],
    rnase1_vs_rnase3 = cor_matrix["rnase1", "rnase3"],
    rnase2_vs_rnase3 = cor_matrix["rnase2", "rnase3"]
  ))
}
#Ergebnisse
View(rnase_correlations)
plot(rnase_correlations)
```

####Normalization###

```{r}
# function to compute mean columnwise (except Protein_Name)
compute_column_means <- function(df) {
  # select numeric columns (except Protein_Name)
  numeric_data <- df[, sapply(df, is.numeric)]
  
  # calculate mean coulmnwise
  col_means <- colMeans(numeric_data, na.rm = TRUE)
  
  return(col_means)
}

#apply to our data
ctrl_means <- compute_column_means(df_ctrl)
rnase_means <- compute_column_means(df_rnase)


# save means as dataframes
ctrl_means_df <- data.frame(Sample = names(ctrl_means), Mean = as.numeric(ctrl_means))
rnase_means_df <- data.frame(Sample = names(rnase_means), Mean = as.numeric(rnase_means))

#depict results
head(ctrl_means_df)
head(rnase_means_df)

#check whether there are means == 0 (to calculate normalization factor: mean are denominator -> would create NAs if mean were 0)
sum(ctrl_means_df[, 2] == 0)
sum(rnase_means_df[, 2]==0)

```

```{r}
# create function to calculate the mean of the two most similar replicates (out of three replicates)
mean_of_closest_pair <- function(x) {
  combs <- combn(x, 2)                          # all pairwise combinations
  diffs <- abs(combs[1, ] - combs[2, ])         # calculates the absolute distance
  min_idx <- which.min(diffs)                   # indices of minimal distance replicates
  mean(combs[, min_idx])                        # mean of the most similar pair
}

# alter function so it will be applied to three values at a time moving fractionwise
process_blocks <- function(values_vector) {
  n_blocks <- length(values_vector) / 3         # number of fractions
  result <- numeric(n_blocks)
  
  for (i in 1:n_blocks) {
    block <- values_vector[((i - 1) * 3 + 1):(i * 3)] #values vector contains the three values of the replicates for each fraction
    result[i] <- mean_of_closest_pair(block)
  }
  
  return(result)
}

# extract values from the dataframe 
control_values <- ctrl_means_df$Mean    
rnase_values   <- rnase_means_df$Mean

# apply to our data
control_means <- process_blocks(control_values)
rnase_means   <- process_blocks(rnase_values)

# save result as dataframe
closest_means_ctrl <- data.frame(
  Fraktion = paste0("Fraction", 1:length(control_means)),  
  Control_most_similar_pair_mean  = control_means
)

closest_means_rnase <- data.frame(
  Fraktion = paste0("Fraction", 1:length(control_means)),  
  RNase_most_similar_pair_mean = rnase_means)

# depict result
print(closest_means_ctrl)
print(closest_means_rnase)

```

```{r}
n_fractions <- 25
n_replicates <- 3

# ctrl_means_df und rnase_means_df enthalten alle Replikat-Mittelwerte in einer Spalte, z.B. 'Means'
# ctrl_final_means_df und rnase_final_means_df enthalten je einen Mittelwert pro Fraktion in 'FinalMean'

# create matrix for replicates of each fraction (25x3)
ctrl_mat <- matrix(ctrl_means_df$Mean, nrow = n_fractions, ncol = n_replicates, byrow = TRUE)
rnase_mat <- matrix(rnase_means_df$Mean, nrow = n_fractions, ncol = n_replicates, byrow = TRUE)

# initialize normalization matrixes
norm_ctrl_mat <- matrix(NA, nrow = n_fractions, ncol = n_replicates)
norm_rnase_mat <- matrix(NA, nrow = n_fractions, ncol = n_replicates)

# loop over all fractions
for (r in 1:n_fractions) {
  control_values <- ctrl_mat[r, ]  # 3 replicates Control
  rnase_values <- rnase_mat[r, ]   # 3 replicates RNase
  
  # FinalMean from Ctrl and RNAse dataframe
  mean_control <- closest_means_ctrl[r, 2]
  mean_rnase <- closest_means_rnase[r, 2]
  
  # check if only one value per fraction
  if(length(mean_control) != 1 | length(mean_rnase) != 1) {
    stop(paste("Mehr oder weniger als ein FinalMean für Fraktion", r))
  }
  
  # calculate normalization factors
  norm_ctrl_mat[r, ] <- mean_control / control_values
  norm_rnase_mat[r, ] <- mean_rnase / rnase_values
}

#depict results
head(norm_ctrl_mat)
head(norm_rnase_mat)

#check if any NAs were created
sum(is.na(norm_ctrl_mat))
sum(is.na(norm_rnase_mat))
```

```{r}

normalize_df <- function(df, norm_mat) {
  # extract numeric data (not "Protein_Name")
  data_mat <- as.matrix(df[, -1])
  
  # check dimensions
  n_blocks <- nrow(norm_mat)
  cols_per_block <- ncol(norm_mat)
  
  # blockwise normalization: Normierungsmatrix wird spaltenweise durchlaufen und in dieser Reihenfolge auf die Spalten der Originaldaten angewendet
  for (i in 1:n_blocks) {
    for (j in 1:cols_per_block) {
      col_index <- (i - 1) * cols_per_block + j
      data_mat[, col_index] <- data_mat[, col_index] * norm_mat[i, j]
    }
  }
  
  # create dataframe as result
  result_df <- cbind(Protein_Name = df$Protein_Name, as.data.frame(data_mat))
  return(result_df)
}

# apply to our data
normed_ctrl_df  <- normalize_df(df_ctrl, norm_ctrl_mat)
normed_rnase_df <- normalize_df(df_rnase, norm_rnase_mat)

# depict results
head(normed_ctrl_df)
head(normed_rnase_df)


```


```{r}
# Mean filter function for a row (preserving first and last value)
smooth_and_reorder <- function(df, n_fractions = 25, n_replicates = 3) {
  proteins <- df[, 1]
  
  smoothed_reps <- lapply(1:n_replicates, function(rep) {
    cols <- seq(1 + rep, 1 + rep + (n_fractions - 1) * 3, by = 3)
    rep_data <- df[, cols]
    
    smoothed_data <- matrix(NA, nrow = nrow(rep_data), ncol = n_fractions)
    smoothed_data[, 1] <- rep_data[, 1]
    smoothed_data[, n_fractions] <- rep_data[, n_fractions]
    
    for (i in 2:(n_fractions - 1)) {
      smoothed_data[, i] <- rowMeans(rep_data[, (i - 1):(i + 1)], na.rm = TRUE)
    }
    
    smoothed_df <- as.data.frame(smoothed_data)
    colnames(smoothed_df) <- paste0("Fraction", 1:n_fractions, "_Rep", rep)
    smoothed_df
  })
  
  combined_df <- do.call(cbind, smoothed_reps)
  
  # sort columns: first all replicates of first fraction, then fraction 2, etc.
  sorted_cols <- unlist(lapply(1:n_fractions, function(frac) {
    paste0("Fraction", frac, "_Rep", 1:n_replicates)
  }))
  
  final_df <- cbind(Protein = proteins, combined_df[, sorted_cols])
  return(final_df)
}

# apply to our data
final_smoothed_ctrl <- smooth_and_reorder(normed_ctrl_df)
final_smoothed_rnase <- smooth_and_reorder(normed_rnase_df)

# depict result
head(final_smoothed_ctrl)
head(final_smoothed_rnase)

#check if any NAs were created
sum(is.na(final_smoothed_ctrl))
sum(is.na(final_smoothed_rnase))

```



```{r}
#save dataframes for batch effect
dir.create("data", showWarnings = FALSE)
saveRDS(final_smoothed_ctrl, file = "data/final_smoothed_ctrl.rds")
saveRDS(final_smoothed_rnase, file =  "data/final_smoothed_rnase.rds")
```

```{r}
# check for any rows with rowSum == 0 (per replicate)
check_zero_replicates_detailed <- function(df) {
  # Remove first column (protein names)
  data_only <- df[, -1]
  protein_names <- df[, 1]
  
  # Initialize lists to store results
  zero_count <- integer(nrow(data_only))
  zero_replicates <- character(nrow(data_only))
  
  # Loop through each row (protein)
  for (i in 1:nrow(data_only)) {
    affected_reps <- c()  # Temporary holder for replicate names
    
    for (rep in 1:3) {
      # Select columns for this replicate across all fractions
      replicate_indices <- seq(from = rep, to = ncol(data_only), by = 3)
      
      # Calculate sum for this replicate
      rep_sum <- sum(data_only[i, replicate_indices])
      
      # If sum is zero, store the replicate name
      if (rep_sum == 0) {
        affected_reps <- c(affected_reps, paste0("Replicate", rep))
      }
    }
    
    # Store number of zero replicates and their names
    zero_count[i] <- length(affected_reps)
    zero_replicates[i] <- if (length(affected_reps) > 0) paste(affected_reps, collapse = ", ") else NA
  }
  
  # Create final summary data frame
  summary_df <- data.frame(
    Protein = protein_names,
    Zero_Replicate_Count = zero_count,
    Affected_Replicates = zero_replicates,
    stringsAsFactors = FALSE
  )
  
  # Optional: filter to only those with at least one zero replicate
  summary_df <- summary_df[summary_df$Zero_Replicate_Count > 0, ]
  
  return(summary_df)
}

# Run for control
ctrl_zero_summary <- check_zero_replicates_detailed(final_smoothed_ctrl)

# Run for RNase
rnase_zero_summary <- check_zero_replicates_detailed(final_smoothed_rnase)

# View examples
head(ctrl_zero_summary)
head(rnase_zero_summary)


```


```{r}
#normalize total amount per replicate to 100%
calc_fraction_percentages <- function(df, zero_info, n_fractions = 25, n_replicates = 3) {
  proteins <- df[, 1]
  percent_reps <- list()
  
  for (rep in 1:n_replicates) {
    # Select replicate columns for all fractions (e.g., Rep1 of all fractions)
    cols <- seq(1 + rep, 1 + rep + (n_fractions - 1) * 3, by = 3)
    rep_data <- as.matrix(df[, cols])
    
    # Get logical vector: TRUE if replicate sum == 0 (should NOT be normalized)
    rep_name <- paste0("Replicate", rep)
    skip_replicate <- zero_info[[rep_name]] == TRUE  # original values are kept

    
    # Calculate row sums
    row_sums <- rowSums(rep_data, na.rm = TRUE)
    
    # Normalize only where rowSum != 0
    percent_data <- rep_data  # start with original values
    
    # Normalize where allowed (i.e., rowSum != 0)
    normalize_rows <- !skip_replicate
    percent_data[normalize_rows, ] <- sweep(
      rep_data[normalize_rows, ],
      1,
      row_sums[normalize_rows],
      FUN = "/"
    ) * 100
    
    # Create dataframe and set column names
    percent_df <- as.data.frame(percent_data)
    colnames(percent_df) <- paste0("Fraction", 1:n_fractions, "_Rep", rep)
    percent_reps[[rep]] <- percent_df
  }
  
  # Combine all replicate dataframes
  combined_percent_df <- do.call(cbind, percent_reps)
  
  # Reorder columns: Fraction1_Rep1, Fraction1_Rep2, Fraction1_Rep3, etc.
  sorted_cols <- unlist(lapply(1:n_fractions, function(frac) {
    paste0("Fraction", frac, "_Rep", 1:n_replicates)
  }))
  
  final_percent_df <- cbind(Protein = proteins, combined_percent_df[, sorted_cols])
  return(final_percent_df)
}


# Run the replicate-zero check
ctrl_zero_info <- check_zero_replicates(final_smoothed_ctrl)
rnase_zero_info <- check_zero_replicates(final_smoothed_rnase)

# Run the adjusted percentage calculation
percent_ctrl_df <- calc_fraction_percentages(final_smoothed_ctrl, ctrl_zero_info)
percent_rnase_df <- calc_fraction_percentages(final_smoothed_rnase, rnase_zero_info)

# View results
head(percent_ctrl_df)
head(percent_rnase_df)

#check for NAs
sum(is.na(percent_ctrl_df))
sum(is.na(percent_rnase_df))
```

```{r}
# save dataframe for t-test
saveRDS(percent_ctrl_df, file = "data/percent_ctrl_df.rds")
saveRDS(percent_rnase_df, file =  "data/percent_rnase_df.rds")
```


```{r}
calculate_mean_per_fraction <- function(df, n_fractions = 25, n_replicates = 3) {
  proteins <- df[, 1]  # Protein-Names
  data_only <- df[, -1]  # only numeric values

  mean_matrix <- matrix(NA, nrow = nrow(data_only), ncol = n_fractions)

  for (f in 1:n_fractions) {
    # columns for fraction f (3 replicates each)
    cols <- ((f - 1) * n_replicates + 1):(f * n_replicates)
    mean_matrix[, f] <- rowMeans(data_only[, cols], na.rm = TRUE)
  }

  # save result as dataframe
  mean_df <- as.data.frame(mean_matrix)
  colnames(mean_df) <- paste0("Fraction", 1:n_fractions)
  final_df <- cbind(Protein = proteins, mean_df)

  return(final_df)
}

#apply to our data
mean_ctrl_df <- calculate_mean_per_fraction(percent_ctrl_df)
mean_rnase_df <- calculate_mean_per_fraction(percent_rnase_df)

# depict results
head(mean_ctrl_df)
head(mean_rnase_df)

#check if NAs were created
sum(is.na(mean_ctrl_df))
sum(is.na(mean_rnase_df))
```

```{r}
# normalization of amount of protein to equal 100%

calculate_fraction_percentages <- function(mean_df) {
  proteins <- mean_df[, 1]
  data_only <- mean_df[, -1]
  
  # calculate row sum (sum across all fractions for each protein)
  row_totals <- rowSums(data_only, na.rm = TRUE)
  
  # transform amount into percent
  percent_matrix <- sweep(data_only, 1, row_totals, FUN = "/") * 100
  
  # combine result to a dataframe
  percent_df <- cbind(Protein = proteins, as.data.frame(percent_matrix))
  colnames(percent_df) <- colnames(mean_df)
  
  return(percent_df)
}


# apply to our data
normalized_ctrl_df  <- calculate_fraction_percentages(mean_ctrl_df)
normalized_rnase_df <- calculate_fraction_percentages(mean_rnase_df)

# depict result
head(normalized_ctrl_df)
head(normalized_rnase_df)

#check if any NAs were created
sum(is.na(normalized_ctrl_df))
sum(is.na(normalized_rnase_df))


```

```{r}
#for Ctrl
# are there rows with sum == 0 (starting with second column) for Ctrl
zeilensummen <- rowSums(normalized_ctrl_df[, -1])

# boolean vector: TRUE for rows with sum == 0
zeilen_mit_nullsumme <- zeilensummen == 0

# are there any such rows?
any(zeilen_mit_nullsumme)

#für RNase
#are there rows with sum == (starting with second column) for Ctrl
zeilensummen_rnase <- rowSums(normalized_rnase_df[, -1])

# boolean vector: TRUE for rows with sum == 0
zeilen_mit_nullsumme_rnase <- zeilensummen_rnase == 0

# are there any such rows?
any(zeilen_mit_nullsumme_rnase)

 
```


```{r}
#Dataframes speichern
dir.create("data", showWarnings = FALSE)
saveRDS(normalized_ctrl_df, file = "data/normalized_ctrl_df.rds")
saveRDS(normalized_rnase_df, file =  "data/normalized_rnase_df.rds")
```


###Batch Effect###


##boxplot
```{r}
# 1. Matrix mit Expressionswerten extrahieren (ohne Protein-Spalte)
ctrl_expr_matrix <- as.matrix(final_smoothed_ctrl[, -1])  

# 2. Sample-Namen extrahieren
sample_names <- colnames(ctrl_expr_matrix)

# 3. Batch-Labels aus Sample-Namen ziehen (Rep1, Rep2, Rep3)
batch <- sub(".*_(Rep\\d)", "\\1", sample_names)
batch <- factor(batch, levels = c("Rep1", "Rep2", "Rep3"))

# 4. Farben zuordnen
batch_colors <- c("Rep1" = "red", "Rep2" = "green", "Rep3" = "blue")
colors <- batch_colors[as.character(batch)]

# 5. Boxplot zeichnen
boxplot(ctrl_expr_matrix,
        main = "Expression nach Sample (Batch gefärbt)",
        ylab = "Expression",
        xlab = "Samples",
        las = 2,                      # X-Achse: senkrechte Labels
        col = colors,
        outline = FALSE,
        cex.axis = 0.6)              # kleinere Achsenbeschriftung

# 6. Legende hinzufügen
legend("topright",
       legend = names(batch_colors),
       fill = batch_colors,
       title = "Batch")
```

```{r}
head(ctrl_expr_matrix)
```



```{r}

if (!require("BiocManager", quietly = TRUE))
    install.packages("BiocManager")

BiocManager::install("limma")

library(limma)

# 1. Matrix mit Expressionswerten extrahieren (ohne Protein-Spalte)
ctrl_expr_matrix <- as.matrix(final_smoothed_ctrl[, -1])  

# 2. Sample-Namen extrahieren
sample_names <- colnames(ctrl_expr_matrix)

# 3. Batch-Labels aus Sample-Namen ziehen (Rep1, Rep2, Rep3)
batch <- sub(".*_(Rep\\d)", "\\1", sample_names)
batch <- factor(batch, levels = c("Rep1", "Rep2", "Rep3"))

# 4. Log2-Transformation (falls nötig, empfohlen wegen Skalenproblem)
ctrl_expr_matrix_log <- log2(ctrl_expr_matrix + 1)

# 5. Batch-Korrektur mit limma
ctrl_expr_corrected <- removeBatchEffect(ctrl_expr_matrix_log, batch = batch)

# 5. Boxplot zeichnen vor korrektur 
boxplot(ctrl_expr_matrix,
        main = "Expression vor Korrektur (Batch gefärbt)",
        ylab = "Expression",
        xlab = "Samples",
        las = 2,                      # X-Achse: senkrechte Labels
        col = colors,
        outline = FALSE,
        cex.axis = 0.6)              # kleinere Achsenbeschriftung

# Boxplot nach Korrektur 
boxplot(ctrl_expr_corrected,
        main = "Expression nach Korrektur (Batch gefärbt)",
        ylab = "Expression",
        xlab = "Samples",
        las = 2,                      # X-Achse: senkrechte Labels
        col = colors,
        outline = FALSE,
        cex.axis = 0.6)              # kleinere Achsenbeschriftung


# 6. Legende hinzufügen
legend("topright",
       legend = names(batch_colors),
       fill = batch_colors,
       title = "Batch")
```


## PCA
```{r}
# PCA-Analyse vorbereiten
pca_before <- prcomp(t(ctrl_expr_matrix), scale. = TRUE)
pca_after  <- prcomp(t(ctrl_expr_corrected), scale. = TRUE)

# Batch-Zuordnung erneut für Farben
# 2. Sample-Namen extrahieren
sample_names <- colnames(ctrl_expr_matrix)

# 3. Batch-Labels aus Sample-Namen ziehen (Rep1, Rep2, Rep3)
batch <- sub(".*_(Rep\\d)", "\\1", sample_names)
batch <- factor(batch, levels = c("Rep1", "Rep2", "Rep3"))
# Plot nebeneinander
par(mfrow = c(1, 2))

# PCA vor Korrektur
plot(pca_before$x[, 1:2],
     col = rainbow(length(levels(batch)))[batch],
     pch = 19,
     main = "PCA vor Batch-Korrektur")
legend("topright", legend = levels(batch), col = rainbow(length(levels(batch))), pch = 19)

# PCA nach Korrektur
plot(pca_after$x[, 1:2],
     col = rainbow(length(levels(batch)))[batch],
     pch = 19,
     main = "PCA nach Batch-Korrektur")
legend("topright", legend = levels(batch), col = rainbow(length(levels(batch))), pch = 19)

# Reset Layout
par(mfrow = c(1, 1))
```

##heatmap
```{r}
# Optional: Wenn du pheatmap noch nicht hast
install.packages("pheatmap")
library(pheatmap)

# Auswahl einer Teilmenge der Proteine (z. B. Top 100 variabelsten)
select_top_var <- function(mat, top_n = 100) {
  vars <- apply(mat, 1, var)
  mat[order(vars, decreasing = TRUE)[1:top_n], ]
}

# Top 100 Gene mit höchster Varianz (vorher/nachher)
heat_before <- select_top_var(expr_matrix, 100)
heat_after  <- select_top_var(expr_corrected, 100)

# Spaltenannotation nach Batch
annotation_col <- data.frame(Batch = batch)
rownames(annotation_col) <- colnames(expr_matrix)

# Zwei Heatmaps nebeneinander
par(mfrow = c(1, 2))

pheatmap(heat_before,
         main = "Heatmap vor Batch-Korrektur",
         annotation_col = annotation_col,
         show_rownames = FALSE,
         cluster_cols = TRUE)

pheatmap(heat_after,
         main = "Heatmap nach Batch-Korrektur",
         annotation_col = annotation_col,
         show_rownames = FALSE,
         cluster_cols = TRUE)

# Reset Layout
par(mfrow = c(1, 1))
```


```{r}

#protein name wieder rein
ctrl_expr_corrected_df <- data.frame(
  Protein = final_smoothed_ctrl[, 1],  # ursprüngliche erste Spalte
  rnase_expr_corrected,                # korrigierte Matrix
  check.names = FALSE                  # verhindert Umbenennung von Spalten
)

colnames(ctrl_expr_corrected_df)
```

```{r}
head(ctrl_expr_corrected)
```

##rnase 

##boxplot 
```{r}
# 1. Matrix mit Expressionswerten extrahieren (ohne Protein-Spalte)
rnase_expr_matrix <- as.matrix(final_smoothed_rnase[, -1])  

# 2. Sample-Namen extrahieren
sample_names <- colnames(rnase_expr_matrix)

# 3. Batch-Labels aus Sample-Namen ziehen (Rep1, Rep2, Rep3)
batch <- sub(".*_(Rep\\d)", "\\1", sample_names)
batch <- factor(batch, levels = c("Rep1", "Rep2", "Rep3"))

# 4. Farben zuordnen
batch_colors <- c("Rep1" = "red", "Rep2" = "green", "Rep3" = "blue")
colors <- batch_colors[as.character(batch)]

# 5. Boxplot zeichnen
boxplot(rnase_expr_matrix,
        main = "Expression nach Sample (Batch gefärbt)",
        ylab = "Expression",
        xlab = "Samples",
        las = 2,                      # X-Achse: senkrechte Labels
        col = colors,
        outline = FALSE,
        cex.axis = 0.6)              # kleinere Achsenbeschriftung

# 6. Legende hinzufügen
legend("topright",
       legend = names(batch_colors),
       fill = batch_colors,
       title = "Batch")
```

```{r}
head(rnase_expr_matrix)
```


```{r}
library(limma)

# 1. Matrix mit Expressionswerten extrahieren (ohne Protein-Spalte)
rnase_expr_matrix <- as.matrix(final_smoothed_rnase[, -1])  

# 2. Sample-Namen extrahieren
sample_names <- colnames(rnase_expr_matrix)

# 3. Batch-Labels aus Sample-Namen ziehen (Rep1, Rep2, Rep3)
batch <- sub(".*_(Rep\\d)", "\\1", sample_names)
batch <- factor(batch, levels = c("Rep1", "Rep2", "Rep3"))

# 4. Log2-Transformation (falls nötig, empfohlen wegen Skalenproblem)
rnase_expr_matrix_log <- log2(rnase_expr_matrix + 1)

# 5. Batch-Korrektur mit limma
rnase_expr_corrected <- removeBatchEffect(rnase_expr_matrix_log, batch = batch)

# 5. Boxplot zeichnen vor korrektur 
boxplot(rnase_expr_matrix,
        main = "Expression vor Korrektur (Batch gefärbt)",
        ylab = "Expression",
        xlab = "Samples",
        las = 2,                      # X-Achse: senkrechte Labels
        col = colors,
        outline = FALSE,
        cex.axis = 0.6)              # kleinere Achsenbeschriftung

# Boxplot nach Korrektur 
boxplot(rnase_expr_corrected,
        main = "Expression nach Korrektur (Batch gefärbt)",
        ylab = "Expression",
        xlab = "Samples",
        las = 2,                      # X-Achse: senkrechte Labels
        col = colors,
        outline = FALSE,
        cex.axis = 0.6)              # kleinere Achsenbeschriftung


# 6. Legende hinzufügen
legend("topright",
       legend = names(batch_colors),
       fill = batch_colors,
       title = "Batch")
```


## PCA
```{r}
# PCA-Analyse vorbereiten
pca_before <- prcomp(t(rnase_expr_matrix), scale. = TRUE)
pca_after  <- prcomp(t(rnase_expr_corrected), scale. = TRUE)

# Batch-Zuordnung erneut für Farben
# 2. Sample-Namen extrahieren
sample_names <- colnames(rnase_expr_matrix)

# 3. Batch-Labels aus Sample-Namen ziehen (Rep1, Rep2, Rep3)
batch <- sub(".*_(Rep\\d)", "\\1", sample_names)
batch <- factor(batch, levels = c("Rep1", "Rep2", "Rep3"))
# Plot nebeneinander
par(mfrow = c(1, 2))

# PCA vor Korrektur
plot(pca_before$x[, 1:2],
     col = rainbow(length(levels(batch)))[batch],
     pch = 19,
     main = "PCA vor Batch-Korrektur")
legend("topright", legend = levels(batch), col = rainbow(length(levels(batch))), pch = 19)

# PCA nach Korrektur
plot(pca_after$x[, 1:2],
     col = rainbow(length(levels(batch)))[batch],
     pch = 19,
     main = "PCA nach Batch-Korrektur")
legend("topright", legend = levels(batch), col = rainbow(length(levels(batch))), pch = 19)

# Reset Layout
par(mfrow = c(1, 1))
```

##heatmap
```{r}
# Optional: Wenn du pheatmap noch nicht hast
install.packages("pheatmap")
library(pheatmap)

# Auswahl einer Teilmenge der Proteine (z. B. Top 100 variabelsten)
select_top_var <- function(mat, top_n = 100) {
  vars <- apply(mat, 1, var)
  mat[order(vars, decreasing = TRUE)[1:top_n], ]
}

# Top 100 Gene mit höchster Varianz (vorher/nachher)
heat_before <- select_top_var(rnase_expr_matrix, 100)
heat_after  <- select_top_var(rnase_expr_corrected, 100)

# Spaltenannotation nach Batch
annotation_col <- data.frame(Batch = batch)
rownames(annotation_col) <- colnames(rnase_expr_matrix)

# Zwei Heatmaps nebeneinander
par(mfrow = c(1, 2))

pheatmap(heat_before,
         main = "Heatmap vor Batch-Korrektur",
         annotation_col = annotation_col,
         show_rownames = FALSE,
         cluster_cols = TRUE)

pheatmap(heat_after,
         main = "Heatmap nach Batch-Korrektur",
         annotation_col = annotation_col,
         show_rownames = FALSE,
         cluster_cols = TRUE)

# Reset Layout
par(mfrow = c(1, 1))

```

```{r}
#protein name wieder rein
rnase_expr_corrected_df <- data.frame(
  Protein = final_smoothed_rnase[, 1],  # ursprüngliche erste Spalte
  rnase_expr_corrected,                # korrigierte Matrix
  check.names = FALSE                  # verhindert Umbenennung von Spalten
)
```


```{r}
head(rnase_expr_corrected)
```
=======
head(expr_corrected)

##SVA
```{r}
# Lade benötigte Libraries
library(sva)
library(stringr)
library(limma)

# 1) Expressionsmatrix (ohne Protein-Spalte)
expression_matrix <- as.matrix(final_smoothed_ctrl[, -1])
rownames(expression_matrix) <- final_smoothed_ctrl$Protein

# 2) Metadaten (sampleInfo) aus Spaltennamen erzeugen
samples <- colnames(expression_matrix)

# Extrahiere "Fraction" und "Replicate" Informationen aus Spaltennamen
fraction <- str_extract(samples, "Fraction\\d+")
replicate <- str_extract(samples, "Rep\\d+")

# sampleInfo DataFrame erstellen
sampleInfo <- data.frame(
  fraction = factor(fraction),
  replicate = factor(replicate)
)

# 3) Designmatrix für das Modell erstellen
mod <- model.matrix(~ fraction + replicate, data = sampleInfo)
mod0 <- model.matrix(~ 1, data = sampleInfo)  # Nullmodell ohne Prädiktoren

# 4) SVA durchführen
sva_res <- sva(expression_matrix, mod, mod0)

# 5) Designmatrix um die gefundenen Surrogate Variablen (SVs) erweitern
mod_sv <- cbind(mod, sva_res$sv)

# 6) OPTIONAL: Wenn du einen bekannten Batch hast, kannst du alternativ ComBat verwenden
# Beispiel (nur wenn du 'batch' hast):
# batch <- sampleInfo$batch_variable
# expression_corrected <- ComBat(dat = expression_matrix, batch = batch, mod = mod)

# 7) Korrektur mit Surrogate Variablen durch lineare Regression (empfohlen bei unbekanntem Batch)
# Fit des linearen Modells mit Surrogate Variablen
fit <- lmFit(expression_matrix, mod_sv)
fit <- eBayes(fit)

# Residuen extrahieren = korrigierter Datensatz ohne die erklärten Effekte (fraction + replicate + SVs)
corrected_expr <- residuals(fit, expression_matrix)

# 'corrected_expr' enthält die bereinigten Expressionswerte

```


```{r}

# Batch-Vektor: z.B. basierend auf 'Rep' in den Spaltennamen
batch <- factor(str_extract(colnames(expression_matrix), "Rep\\d+"))

# Farben je Batch
batch_levels <- levels(batch)
batch_colors <- rainbow(length(batch_levels))
names(batch_colors) <- batch_levels
colors <- batch_colors[batch]

```

##boxplot


```{r}
# 1. Boxplot vor Korrektur
boxplot(expression_matrix,
        main = "Expression vor Korrektur (Replicate gefärbt)",
        ylab = "Expression",
        xlab = "Samples",
        las = 2,
        col = colors,
        outline = FALSE,
        cex.axis = 0.6)

# 2. Boxplot nach SVA-Korrektur (z. B. residuals oder sva-adjusted)
boxplot(corrected_expr,
        main = "Expression nach SVA-Korrektur (Replicate gefärbt)",
        ylab = "Expression",
        xlab = "Samples",
        las = 2,
        col = colors,
        outline = FALSE,
        cex.axis = 0.6)

# 3. Legende
legend("topright",
       legend = names(batch_colors),
       fill = batch_colors,
       title = "Replicate")

```
##PCA
```{r}

# 1) PCA vorbereiten
pca_before <- prcomp(t(expression_matrix), scale. = TRUE)
pca_after  <- prcomp(t(corrected_expr), scale. = TRUE)

# 2) Batch-Zuordnung erneut für Farben
sample_names <- colnames(expression_matrix)
batch <- sub(".*_(Rep\\d)", "\\1", sample_names)
batch <- factor(batch, levels = c("Rep1", "Rep2", "Rep3"))

# 3) Farben definieren für die Replikate
batch_colors <- rainbow(length(levels(batch)))

# 4) PCA-Plot: nebeneinander
par(mfrow = c(1, 2))  # Zwei Plots nebeneinander

# --- PCA vor Korrektur ---
plot(pca_before$x[, 1:2],
     col = batch_colors[batch],
     pch = 19,
     main = "PCA vor Batch-Korrektur",
     xlab = "PC1", ylab = "PC2")
legend("topright", legend = levels(batch), col = batch_colors, pch = 19)

# --- PCA nach Korrektur ---
plot(pca_after$x[, 1:2],
     col = batch_colors[batch],
     pch = 19,
     main = "PCA nach SVA-Korrektur",
     xlab = "PC1", ylab = "PC2")
legend("topright", legend = levels(batch), col = batch_colors, pch = 19)

# 5) Layout zurücksetzen
par(mfrow = c(1, 1))

```

##Heatmap
```{r}
# 1) Falls noch nicht installiert:
# install.packages("pheatmap")
library(pheatmap)

# 2) Hilfsfunktion: Top-N variabelste Proteine auswählen
select_top_var <- function(mat, top_n = 100) {
  vars <- apply(mat, 1, var)
  mat[order(vars, decreasing = TRUE)[1:top_n], ]
}

# 3) Top 100 variabelsten Proteine extrahieren
heat_before <- select_top_var(expression_matrix, 100)
heat_after  <- select_top_var(corrected_expr, 100)

# 4) Spaltenannotation: Replikate als Batch
annotation_col <- data.frame(Batch = batch)
rownames(annotation_col) <- colnames(expression_matrix)

# 5) Heatmaps zeichnen (jeweils mit Annotation)
# Hinweis: pheatmap unterstützt kein par(mfrow), daher separate Plots empfohlen

# --- Heatmap vor Korrektur ---
pheatmap(heat_before,
         main = "Heatmap vor Batch-Korrektur",
         annotation_col = annotation_col,
         show_rownames = FALSE,
         cluster_cols = TRUE,
         fontsize_col = 6)

# --- Heatmap nach Korrektur ---
pheatmap(heat_after,
         main = "Heatmap nach SVA-Korrektur",
         annotation_col = annotation_col,
         show_rownames = FALSE,
         cluster_cols = TRUE,
         fontsize_col = 6)

```

######PART 2
###Data analysis
```{r}
#visualize distribution for one protein -> hilft uns u.a. zu beurteilen ob Maxima-Funktion funktioniert
# Protein auswählen
protein_id <- "SPB6_HUMAN"

# extract amount of protein
intensities <- as.numeric(normalized_ctrl_df[4, 2:26 ])
fraktionen <- 1:25

# Plot 
plot(fraktionen, intensities, type = "n",
       xlab = "Fraktion (1–25)", ylab = "Normierte Intensität (Fläche = 1)",
       main = paste("Dichte-Plot von", protein_id),
       ylim = c(0, max(intensities)*1.1))

 polygon(c(fraktionen, rev(fraktionen)),
          c(rep(0, length(fraktionen)), rev(intensities)),
          col = "lavender", border = NA)
  lines(fraktionen, intensities, col = "lavender", lwd = 2)
```

```{r}
#visualize distribution for one protein -> hilft uns u.a. zu beurteilen ob Maxima-Funktion funktioniert
# Protein auswählen
protein_id <- "SPB6_HUMAN"

# extract amount of protein
intensities <- as.numeric(normalized_ctrl_df[4, 2:26 ])
fraktionen <- 1:25

# Plot 
plot(fraktionen, intensities, type = "n",
       xlab = "Fraktion (1–25)", ylab = "Normierte Intensität (Fläche = 1)",
       main = paste("Dichte-Plot von", protein_id),
       ylim = c(0, max(intensities)*1.1))

 polygon(c(fraktionen, rev(fraktionen)),
          c(rep(0, length(fraktionen)), rev(intensities)),
          col = "lavender", border = NA)
  lines(fraktionen, intensities, col = "lavender", lwd = 2)
```

```{r}
#find all maxima
# recognize peaks with diff()
find_peaks_diff <- function(x, threshold = 2) {
  n <- length(x)
  peaks <- logical(n)
  
  dx <- diff(x)
  
  # Interne Punkte prüfen: vorher steigend, danach fallend
  for (i in 2:(n-1)) {
    if (x[i] >= threshold && dx[i-1] > 0 && dx[i] < 0) {
      peaks[i] <- TRUE
    }
  }
  
  # Ränder prüfen
  if (x[1] >= threshold && x[1] > x[2]) peaks[1] <- TRUE
  if (x[n] >= threshold && x[n] > x[n-1]) peaks[n] <- TRUE
  
  which(peaks)
}

# Beispielhafte Anwendung auf Dataframe mit Protein in Spalte 1 und 25 Messwerten in Spalten 2–26
process_df_peaks <- function(df, threshold = 2) {
  results <- lapply(1:nrow(df), function(i) {
    intensities <- as.numeric(df[i, 2:26])
    protein <- df[i, 1]
    peaks <- find_peaks_diff(intensities, threshold)
    list(Protein = protein, Peaks = peaks)
  })
  
  # Ergebnis in Dataframe umwandeln: Peaks als kommaseparierte Liste oder NA, falls keine Peaks
  df_peaks <- data.frame(
    Protein = sapply(results, `[[`, "Protein"),
    Maxima_Positions = sapply(results, function(x) {
      if (length(x$Peaks) == 0) {
        NA_character_
      } else {
        paste(x$Peaks, collapse = ",")
      }
    }),
    stringsAsFactors = FALSE
  )
  
  return(df_peaks)
}

# apply to our dataframe

df_peaks_CTRL <- process_df_peaks(normalized_ctrl_df, threshold = 2)
df_peaks_RNAse <- process_df_peaks(normalized_rnase_df, threshold = 2)


# depict results
head(df_peaks_CTRL)
head(df_peaks_RNAse)

```

```{r}
# Funktion zum Finden des globalen Maximums (ggf. mittlerer Index bei mehreren)
find_global_maxima <- function(x, threshold = 2) {
  max_val <- max(x)
  if (max_val >= threshold) {
    max_positions <- which(x == max_val)
    if (length(max_positions) == 1) {
      return(max_positions)
    } else {
      middle_index <- mean(range(max_positions))
      return(middle_index)
    }
  } else {
    return(NA_real_)  # Kein gültiges Maximum
  }
}

# DataFrame-Verarbeitung
process_df_global_maxima <- function(df, threshold = 2) {
  results <- lapply(1:nrow(df), function(i) {
    intensities <- as.numeric(df[i, 2:26])
    protein <- df[i, 1]
    maxima <- find_global_maxima(intensities, threshold)
    list(Protein = protein, Global_Maximum = maxima)
  })
  
  df_maxima <- data.frame(
    Protein = sapply(results, `[[`, "Protein"),
    Global_Maximum = sapply(results, `[[`, "Global_Maximum"),
    stringsAsFactors = FALSE
  )
  
  return(df_maxima)
}

# Anwenden auf deine DataFrames
global_ctrl <- process_df_global_maxima(normalized_ctrl_df, threshold = 2)
global_rnase <- process_df_global_maxima(normalized_rnase_df, threshold = 2)

head(global_ctrl)

```

```{r}
global_ctrl$Global_Maximum <- as.numeric(as.character(global_ctrl$Global_Maximum))
global_rnase$Global_Maximum <- as.numeric(as.character(global_rnase$Global_Maximum))

shift_distance <- global_rnase$Global_Maximum - global_ctrl$Global_Maximum

# Richtung bestimmen
shift_direction <- ifelse(shift_distance > 0, "right shift",
                    ifelse(shift_distance < 0, "left shift",
                           "No Shift"))

# Ergebnis zusammenfassen
shift_result <- data.frame(
  Protein = global_ctrl$Protein,
  Position_Control = global_ctrl$Global_Maximum,
  Position_RNase = global_rnase$Global_Maximum,
  Shift_Distance = shift_distance,
  Shift_Direction = shift_direction
)

head(shift_result)
```

```{r}
# Histogramm
hist(abs(shift_result$Shift_Distance), breaks = 30, col = "lightblue",
     main = "Histogram of Shift_Distance", xlab = "Shift_Distance", freq = FALSE)

# Dichtekurve hinzufügen
lines(density(shift_result$Shift_Distance), col = "red", lwd = 2)

# Boxplot
boxplot(shift_result$Shift_Distance, main = "Boxplot of Shift_Distance", col = "lightgreen",
        ylab = "Shift_Distance")

# Schiefe (Skewness) berechnen - manuell
x <- shift_result$Shift_Distance
n <- length(x)
m3 <- sum((x - mean(x))^3) / n
s3 <- (sum((x - mean(x))^2) / n)^(3/2)
skewness <- m3 / s3

cat("Skewness:", skewness, "\n")

median(shift_result$Shift_Distance)
```


```{r}
get_global_amplitudes <- function(expression_df, global_ctrl) {
  amplitudes <- mapply(function(row_idx, max_pos_str) {
    # max_pos_str kann mehrere Maxima enthalten, z.B. "5,10"
    max_positions <- as.numeric(unlist(strsplit(max_pos_str, ",")))
    
    if (length(max_positions) == 0 || all(is.na(max_positions))) {
      return(NA)
    }
    
    # Intensitäten an den Maxima (Achtung: +1 wegen Proteinspalte in expression_df)
    intensities <- as.numeric(expression_df[row_idx, max_positions + 1])
    
    # Falls mehrere Maxima, alle Werte als String mit Komma trennen
    paste(intensities, collapse = ",")
  },
  row_idx = 1:nrow(expression_df),
  max_pos_str = as.character(global_ctrl$Global_Maximum)

  )
  
  data.frame(
    Protein = expression_df[[1]],
    Amplitudes = amplitudes,
    stringsAsFactors = FALSE
  )
}

global_amplitudes_ctrl <- get_global_amplitudes(normalized_ctrl_df, global_ctrl)

head(global_amplitudes_ctrl)

```
```{r}
get_global_amplitudes <- function(expression_df, global_rnase) {
  amplitudes <- mapply(function(row_idx, max_pos_str) {
    # max_pos_str kann mehrere Maxima enthalten, z.B. "5,10"
    max_positions <- as.numeric(unlist(strsplit(max_pos_str, ",")))
    
    if (length(max_positions) == 0 || all(is.na(max_positions))) {
      return(NA)
    }
    
    # Intensitäten an den Maxima (Achtung: +1 wegen Proteinspalte in expression_df)
    intensities <- as.numeric(expression_df[row_idx, max_positions + 1])
    
    # Falls mehrere Maxima, alle Werte als String mit Komma trennen
    paste(intensities, collapse = ",")
  },
  row_idx = 1:nrow(expression_df),
  max_pos_str = as.character(global_rnase$Global_Maximum)

  )
  
  data.frame(
    Protein = expression_df[[1]],
    Amplitudes = amplitudes,
    stringsAsFactors = FALSE
  )
}

global_amplitudes_rnase <- get_global_amplitudes(normalized_rnase_df, global_rnase)

head(global_amplitudes_rnase)

```



```{r}
##Gain and loss of amplitude in peak 
# Erst numerisch machen
global_amplitudes_ctrl$Amplitude <- as.numeric(as.character(global_amplitudes_ctrl$Amplitude))
global_amplitudes_rnase$Amplitude <- as.numeric(as.character(global_amplitudes_rnase$Amplitude))

# Verlust: Abnahme der Amplitude nach RNase-Behandlung 
amplitude_loss <- pmax(global_amplitudes_ctrl$Amplitude - global_amplitudes_rnase$Amplitude, 0)

# Zuwachs: Zunahme der Amplitude nach RNase-Behandlung
amplitude_gain <- pmax(global_amplitudes_rnase$Amplitude - global_amplitudes_ctrl$Amplitude, 0)

amplitude_changes <- data.frame(
  Protein = global_amplitudes_ctrl$Protein,
  Amplitude_Control = global_amplitudes_ctrl$Amplitude,
  Amplitude_RNase = global_amplitudes_rnase$Amplitude,
  loss = amplitude_loss,
  gain = amplitude_gain
)

head(amplitude_changes)
```
```{r}
###Addition of all amplitude changes
amplitude_changes$changes <- amplitude_changes$loss + amplitude_changes$gain
amplitude_changes$changes_in25 <- (amplitude_changes$changes/100)*25
head(amplitude_changes)
```

```{r}
# Histogramm
hist(abs(amplitude_changes$changes_in25), breaks = 30, col = "lightblue",
     main = "Histogram of Shift_Distance", xlab = "Shift_Distance", freq = FALSE)

# Dichtekurve hinzufügen
lines(density(amplitude_changes$changes_in25), col = "red", lwd = 2)

# Boxplot
boxplot(amplitude_changes$changes_in25, main = "Boxplot of Shift_Distance", col = "lightgreen",
        ylab = "Shift_Distance")

# Schiefe (Skewness) berechnen - manuell
x <- amplitude_changes$changes_in25
n <- length(x)
m3 <- sum((x - mean(x))^3) / n
s3 <- (sum((x - mean(x))^2) / n)^(3/2)
skewness <- m3 / s3

cat("Skewness:", skewness, "\n")

median(normalized_ctrl_df$EMD)
```


```{r}
# Join beider Dataframes mit globalen Maxima
df_diff_peaks <- shift_result[, 1:3]


# Differenz berechnen (neue Spalte 'diff')
df_diff_peaks$diff <- df_diff_peaks$Position_RNase - df_diff_peaks$Position_Control

# Achsenlimit berechnen
max_val <- max(
  df_diff_peaks$Position_RNase,
  df_diff_peaks$Position_Control,
  na.rm= TRUE
)*1.1

# Farben für Punkte definieren
colors <- ifelse(df_diff_peaks$diff > 0, "pink",
                 ifelse(df_diff_peaks$diff < 0, "lavender", "cyan"))

# Scatterplot erstellen
plot(
  df_diff_peaks$Position_RNase,
  df_diff_peaks$Position_Control,
  xlim = c(0, max_val),
  ylim = c(0, max_val),
  xlab = "Globales Maximum RNase",
  ylab = "Globales Maximum Kontroll",
  main = "Vergleich der globalen Maxima der Proteine",
  pch = 19,
  col = colors
)

# Diagonale Referenzlinie y = x
abline(a = 0, b = 1, col = "grey",lty=2)

```

```{r}
## right shift proteins
# create dataframe with proteins and their shift direction
shift_df <- data.frame(
  Proteins = normalized_ctrl_df$Protein,
  Shift = shift_result$Shift_Direction
)

# sort all right shift proteins in one dataframe
right_shift_df <- shift_df[shift_df$Shift == "right shift", ]
head(right_shift_df)

dim(right_shift_df)
```

```{r}#
##prepare shift dataframe for linear regression
# save rigth shift proteins as text file
write.table(right_shift_df, file = "Right_Shift_Proteins.txt", sep = "\t", row.names = FALSE, quote = FALSE)

```

```{r}
install.packages("emdist")  

```

```{r}
library(emdist)

# Custom function to compute 1D Earth Mover's Distance
compute_emd_1d <- function(vec1, vec2) {
  # Remove NAs
  vec1 <- as.numeric(na.omit(vec1))
  vec2 <- as.numeric(na.omit(vec2))
  
  # Ensure both vectors have the same length
  if (length(vec1) != length(vec2)) {
    return(NA)
  }
  
  # Normalize both vectors to sum to 1 (as probability distributions)
  vec1 <- vec1 / sum(vec1)
  vec2 <- vec2 / sum(vec2)
  
  # Compute cumulative distributions
  cdf1 <- cumsum(vec1)
  cdf2 <- cumsum(vec2)
  
  # EMD in 1D is the sum of absolute differences of CDFs
  emd <- sum(abs(cdf1 - cdf2))
  
  return(emd)
}

# Vector to store EMD results
emd_values <- numeric(nrow(normalized_ctrl_df))

# Loop through all proteins (rows)
for (i in 1:nrow(normalized_ctrl_df)) {
  # Extract fraction profiles (columns 2 to 26)
  vec_ctrl <- as.numeric(normalized_ctrl_df[i, 2:26])
  vec_rnase <- as.numeric(normalized_rnase_df[i, 2:26])
  
  # Compute 1D EMD
  emd_values[i] <- compute_emd_1d(vec_ctrl, vec_rnase)
}

# Add EMD results as a new column to the data frame
normalized_ctrl_df$EMD <- emd_values
normalized_rnase_df$EMD <- emd_values  # Optional, for consistency (values are the same as for Ctrl)

#EMD results can potentially range from 0 (Ctrl and RNase are identical) to 25 (Ctrl and RNase are as dissimilar as they can be)

# depict results
head(normalized_ctrl_df[, c(1, 27)])  # Show protein name and EMD

```

```{r}
# Histogramm
hist(abs(normalized_ctrl_df$EMD), breaks = 30, col = "lightblue",
     main = "Histogram of Shift_Distance", xlab = "Shift_Distance", freq = FALSE)

# Dichtekurve hinzufügen
lines(density(normalized_ctrl_df$EMD), col = "red", lwd = 2)

# Boxplot
boxplot(normalized_ctrl_df$EMD, main = "Boxplot of Shift_Distance", col = "lightgreen",
        ylab = "Shift_Distance")

# Schiefe (Skewness) berechnen - manuell
x <- normalized_ctrl_df$EMD
n <- length(x)
m3 <- sum((x - mean(x))^3) / n
s3 <- (sum((x - mean(x))^2) / n)^(3/2)
skewness <- m3 / s3

cat("Skewness:", skewness, "\n")

```


```{r}
# load dataframe for t-test
percent_ctrl_df <- readRDS("data/percent_ctrl_df.rds")
percent_rnase_df <- readRDS("data/percent_rnase_df.rds")
```

```{r}
# determine global maxima from dataframes with still all 3 replicates in them

# prepare data
# remove protein-column
percent_ctrl <- percent_ctrl_df[, -1]
percent_rnase <- percent_rnase_df[, -1]

# define replicates as steps by 3
rep1_cols <- seq(1, ncol(percent_ctrl), by = 3)
rep2_cols <- seq(2, ncol(percent_ctrl), by = 3)
rep3_cols <- seq(3, ncol(percent_ctrl), by = 3)


# formula for extracting global maxima and their position
get_max_and_pos <- function(mat) {
  max_vals <- apply(mat, 1, max, na.rm = TRUE)
  max_pos <- apply(mat, 1, function(x) {
    if (all(is.na(x))) NA else which.max(x)
  })
  list(value = max_vals, pos = max_pos)
}

# formula for extracting position as numeric fraction value
extract_fraction_number <- function(name_vector) {
  as.numeric(sub("Fraction(\\d+)_Rep\\d+", "\\1", name_vector))
}

# apply formulas on both treatments
ctrl_r1 <- get_max_and_pos(percent_ctrl[, rep1_cols])
ctrl_r2 <- get_max_and_pos(percent_ctrl[, rep2_cols])
ctrl_r3 <- get_max_and_pos(percent_ctrl[, rep3_cols])

rnase_r1 <- get_max_and_pos(percent_rnase[, rep1_cols])
rnase_r2 <- get_max_and_pos(percent_rnase[, rep2_cols])
rnase_r3 <- get_max_and_pos(percent_rnase[, rep3_cols])

# define column names
names_r1 <- colnames(percent_ctrl)[rep1_cols]
names_r2 <- colnames(percent_ctrl)[rep2_cols]
names_r3 <- colnames(percent_ctrl)[rep3_cols]

# define protein names
protein_names <- percent_ctrl_df[, 1]

# save maxima results as dataframes
global_max_ctrl_df <- data.frame(
  Protein = protein_names,
  Max_Rep1 = ctrl_r1$value,
  Max_Rep2 = ctrl_r2$value,
  Max_Rep3 = ctrl_r3$value
)

global_max_rnase_df <- data.frame(
  Protein = protein_names,
  Max_Rep1 = rnase_r1$value,
  Max_Rep2 = rnase_r2$value,
  Max_Rep3 = rnase_r3$value
)

# save fraction position as dataframes
fraktion_pos_ctrl_df <- data.frame(
  Protein = protein_names,
  Max_Pos_Rep1 = extract_fraction_number(names_r1[ctrl_r1$pos]),
  Max_Pos_Rep2 = extract_fraction_number(names_r2[ctrl_r2$pos]),
  Max_Pos_Rep3 = extract_fraction_number(names_r3[ctrl_r3$pos])
)

fraktion_pos_rnase_df <- data.frame(
  Protein = protein_names,
  Max_Pos_Rep1 = extract_fraction_number(names_r1[rnase_r1$pos]),
  Max_Pos_Rep2 = extract_fraction_number(names_r2[rnase_r2$pos]),
  Max_Pos_Rep3 = extract_fraction_number(names_r3[rnase_r3$pos])
)

# depict results
print(global_max_ctrl_df)
print(fraktion_pos_ctrl_df)

print(global_max_rnase_df)
print(fraktion_pos_rnase_df)

## NAs sind noch ein Problem ???
```

```{r}
# t Test over all proteins for the positions of the global maxima
# protein names
protein_names <- fraktion_pos_ctrl_df$Protein

# generate replicate columns
replicate_cols <- c("Max_Pos_Rep1", "Max_Pos_Rep2", "Max_Pos_Rep3")

# DataFrame for p-Values (per protein one value)
p_values_df_global_positions <- data.frame(Protein = protein_names, pValue = NA_real_)

for (i in seq_along(protein_names)) {
  ctrl_vals <- as.numeric(fraktion_pos_ctrl_df[i, replicate_cols])
  rnase_vals <- as.numeric(fraktion_pos_rnase_df[i, replicate_cols])
  
  # search for NAs
  if (length(na.omit(ctrl_vals)) >= 2 && length(na.omit(rnase_vals)) >= 2) {
    test_res <- try(t.test(ctrl_vals, rnase_vals, paired = TRUE), silent = TRUE)
    if (!inherits(test_res, "try-error")) {
      p_values_df_global_positions$pValue[i] <- test_res$p.value
    }
  }
}

print(p_values_df_global_positions)
# still problems with NAs in dataframes !!!!!!!!!!

```

```{r}
# t Test for every fraction over all proteins -> geht das überhaupt weil Daten normalverteilt sind??
# protein names
protein_names <- percent_ctrl_df[, 1]

# define lenght of list
num_fractions <- ncol(percent_ctrl)
p_values_list <- vector("numeric", length = num_fractions)

for (j in 1:num_fractions) {
  ctrl_values <- percent_ctrl[, j]
  rnase_values <- percent_rnase[, j]
  
  # extract only paires without NAs
  valid_idx <- which(!is.na(ctrl_values) & !is.na(rnase_values))
  
  if (length(valid_idx) >= 2) {
    test_res <- try(t.test(ctrl_values[valid_idx], rnase_values[valid_idx], paired = TRUE), silent = TRUE)
    if (!inherits(test_res, "try-error")) {
      p_values_list[j] <- test_res$p.value
    } else {
      p_values_list[j] <- NA
    }
  } else {
    p_values_list[j] <- NA
  }
}

# result as dataframe

p_values_df_all_proteins <- data.frame(t(p_values_list))
colnames(p_values_df_all_proteins) <- colnames(percent_ctrl)
p_values_df_all_proteins$Protein <- "All_Proteins"

# first column with protein names
p_values_df_all_proteins <- p_values_df_all_proteins[, c("Protein", colnames(percent_ctrl))]

print(p_values_df_all_proteins)

```


```{r}
#Wilcoxon test proteinwise -> test statistic is used for testscore
# define variables used
protein_names <- normalized_ctrl_df[, 1]
stat_values <- numeric(length(protein_names))
p_values <- numeric(length(protein_names))

# iterate over all proteins
for (i in seq_along(protein_names)) {
  ctrl_values <- as.numeric(normalized_ctrl_df[i, 2:26])
  rnase_values <- as.numeric(normalized_rnase_df[i, 2:26])
  
  test_result <- wilcox.test(ctrl_values, rnase_values, alternative = "two.sided", paired = TRUE, exact = FALSE)
  
  stat_values[i] <- test_result$statistic
  
 
}

# save result as dataframe
Wilcoxon_df <- data.frame(
  Protein = protein_names,
  Wilcox_Statistic = stat_values
)


# depict result
head(Wilcoxon_df)

```

```{r}
#calculate test statstic for testscore (max. 25%)
#paired Wilcoxon test: W(min) = 0, W(max) = 325
Wilcoxon_df$Wilcox_scaled <- (Wilcoxon_df$Wilcox_Statistic / 325) * 25

#depict results
head(Wilcoxon_df)
```

```{r}
# Robust scaling function: (x - median) / IQR
robust_scale <- function(x) {
  med <- median(x, na.rm = TRUE)
  iqr <- IQR(x, na.rm = TRUE)
  scaled <- (x - med) / iqr
  return(scaled)
}

# Apply robust scaling to each variable
normalized_ctrl_df$EMD_scaled <- robust_scale(normalized_ctrl_df$EMD)
shift_result$Shift_Distance_scaled <- robust_scale(abs(shift_result$Shift_Distance))
amplitude_changes$changes_in25_scaled <- robust_scale(amplitude_changes$changes_in25)
Wilcoxon_df$Wilcox_scaled_scaled <- robust_scale(Wilcoxon_df$Wilcox_scaled)

```


```{r}
#define dataframe for all test scores of all proteines
test_scores_combined_df <- data.frame(
  Protein = normalized_ctrl_df$Protein,
  Shift_Distance_ctrl_to_rnase = shift_result$Shift_Distance_scaled,
  Shift_direction_ctrl_to_rnase = shift_result$Shift_Direction,
  amplitude_changes = amplitude_changes$changes_in25_scaled,
  EMD = normalized_ctrl_df$EMD_scaled,
  Wilcoxon_statistic = Wilcoxon_df$Wilcox_scaled_scaled
)
#depict result
  head(test_scores_combined_df)
  
#check that no NAs were created
sum(is.na(test_scores_combined_df))
```

```{r}
#calculate final testscores
test_scores_combined_df$testscores <- rowSums(test_scores_combined_df[, c(2,4,5,6)])

#depict result
head(test_scores_combined_df)
```



```{r}
# install and load package
install.packages("DT")
library(DT)

# read data
url <- "https://raw.githubusercontent.com/MichelaPozzi/2025-topic-03-group-04/main/table_RBP_lists.csv"
lines <- readLines(url, encoding = "UTF-8")
header <- unlist(strsplit(lines[6], ","))
data <- read.csv(text = lines[7:length(lines)], header = FALSE, sep = ",", stringsAsFactors = FALSE)
colnames(data) <- header

# depict datatable
datatable(data, filter = "top", options = list(pageLength = 25))

# save dataframe locally
write.csv(data, "mein_ergebnis.csv", row.names = FALSE)

#save result as dataframe
RBP_resources <- as.data.frame(data)

#depict result
head(RBP_resources)
```

```{r}
#identify proteins which can potentially be used as negative control
# proteins which were identified as RDPs not more than once
RNA_independent <- RBP_resources[RBP_resources[,4] %in% c(0,1), , drop = FALSE]

# depict result
head(RNA_independent)
```

```{r}
# check which of the potential proteins for negative control are actually contained in our dataset

row_subset <- RNA_independent[,1]
ref_row <- normalized_ctrl_df[,1]

# find common proteins 
common_proteins_negative <- intersect(row_subset, ref_row)

# depict vector with common proteins
length(common_proteins_negative)

# Randomly sample 550 elements from 'common_proteins_positive' 
# (together with 550 positive control proteins, 1100 total — approx. 30% of all proteins,
#  allowing a 30/70 model split)
negative_control <- sample(common_proteins_negative, 550, replace = FALSE) #replace = FALSE -> no protein can be chosen twice

length(negative_control)

```

```{r}
# create dataframe negative control
# extract corresponding proteins from test_scores_combined_df
df_negative_control <- test_scores_combined_df[test_scores_combined_df$Protein %in% negative_control, ] 
# depict result
print(df_negative_control)

max_negative <- max(df_negative_control$testscores)
print(max_negative)
```

```{r}
#identify proteins which can potentially be used as positive control
RNA_dependent <- RBP_resources[RBP_resources[,4] %in% c(8, 9, 10, 11, 12, 13, 14, 15,16, 17, 18), , drop = FALSE]

#depict result
head(RNA_dependent)
```

```{r}
#check which of the potential proteins for negative control are actually contained in our dataset
row_subset <- RNA_dependent[,1]
ref_row <- normalized_ctrl_df[,1]

# find common proteins
common_proteins_positive <- intersect(row_subset, ref_row)

# Output the number of common proteins
length(common_proteins_positive)

# Randomly sample 550 elements from 'common_proteins_positive' 
# (together with 550 negative control proteins, 1100 total — approx. 30% of all proteins,
#  allowing a 30/70 model split)
positive_control <- sample(common_proteins_positive, 550, replace = FALSE)

length(positive_control)
```

```{r}
# create dataframe positive control 
# extract corresponding proteins from test_scores_combined_df 
df_positive_control <- test_scores_combined_df[test_scores_combined_df$Protein %in% positive_control, ] 
# depict result
print(df_positive_control)

max_positive <- max(df_positive_control$testscores)
print(max_positive)
```

```{r}
#check whether positive and negative control are reliable and whether they differ significantly 
# Vector of column indices to test
cols_to_test <- c(2,4,5,6,7)

# Empty list to store test results
test_results <- list()

for (col in cols_to_test) {
  # Extract the column from both dataframes
  pos_values <- df_positive_control[[col]]
  neg_values <- df_negative_control[[col]]
  
  # Perform Wilcoxon Rank Sum test (Mann-Whitney U test)
  test <- wilcox.test(pos_values, neg_values)
  
  # Store the p-value with the column name as key
  test_results[[colnames(df_positive_control)[col]]] <- test$p.value
}

# Create a data frame to display p-values
test_results_df <- data.frame(
  Column = names(test_results),
  p_value = unlist(test_results)
)

# Print the results
print(test_results_df)

```


```{r}
# 1. Add labels to the datasets
# 1. Add labels to the datasets
df_positive_control$label <- 1  # Positive control group labeled as 1
df_negative_control$label <- 0  # Negative control group labeled as 0

# 2. Combine the datasets and keep the relevant columns (features + label)
df_all <- rbind(
  df_positive_control[, c("EMD", "Shift_Distance_ctrl_to_rnase", "amplitude_changes", "Wilcoxon_statistic", "label")],
  df_negative_control[, c("EMD", "Shift_Distance_ctrl_to_rnase", "amplitude_changes", "Wilcoxon_statistic", "label")]
)

# 3. Fit logistic regression model with multiple predictors
logistic_model <- glm(label ~ EMD + Shift_Distance_ctrl_to_rnase + amplitude_changes + Wilcoxon_statistic,
                      data = df_all,
                      family = binomial)

# 4. Display model summary to see weights (coefficients)
summary(logistic_model)

# 5. Create a combined weighted score using coefficients
coeffs <- coef(logistic_model)[-1]  # exclude intercept
df_all$weighted_score <- rowSums(sweep(df_all[, names(coeffs)], 2, coeffs, FUN = "*"))

# 6. Boxplot of weighted scores by label
boxplot(weighted_score ~ label, data = df_all,
        names = c("Negative", "Positive"),
        xlab = "Class Label", ylab = "Weighted Score",
        main = "Distribution of Weighted Scores by Class")

```

```{r}
# 1. Calculate predicted probabilities (e.g., RNA-dependency) using the logistic model
test_scores_combined_df$probability <- predict(logistic_model, newdata = test_scores_combined_df, type = "response")

# 2. View the first few rows of the result
head(test_scores_combined_df)

# 3. Define a threshold for high predicted probability
threshold <- 0.7575896 

# 4. Count how many proteins have a predicted probability above the threshold
sum(test_scores_combined_df$probability > threshold)

```
```{r}
#how to select threshold
# 1. Predict probabilities for the negative control
pos_preds <- predict(logistic_model, newdata = df_positive_control, type = "response")

# 2. Calculate Q3 (75th percentile) of the predicted scores for negative control
q3_pos_preds <- quantile(pos_preds, 0.25, na.rm = TRUE)

# 3. Set threshold just above Q3
threshold <- q3_pos_preds + 1e-6  # small epsilon to avoid ties

# 4. Predict probabilities for the full dataset
all_preds <- predict(logistic_model, newdata = test_scores_combined_df, type = "response")

# 5. Select proteins with predicted probability above the threshold
selected_proteins <- test_scores_combined_df[all_preds > threshold, ]

# 6. Optional: Check how many were selected
cat("Threshold (based on Q3 of negative controls):", threshold, "\n")
cat("Number of proteins selected:", nrow(selected_proteins), "\n")

```


```{r}
# 1. Mark reference proteins in the full dataset
test_scores_combined_df$is_reference <- test_scores_combined_df$Protein %in% df_positive_control$Protein

# 2. Make predictions using the logistic model
predictions <- predict(logistic_model, newdata = test_scores_combined_df, type = "response")

# 3. Apply threshold (e.g., 0.95) to get predicted positives
selected_proteins <- test_scores_combined_df[predictions > 0.3899612, ]

# 4. Count how many of the selected proteins are reference proteins
table(selected_proteins$is_reference)

# Optional: Extract the non-reference hits
predicted_non_reference <- selected_proteins[!selected_proteins$is_reference, ]


#how many proteins of negative control are found at this threshold
# 1. Mark negative control proteins in the full dataset
test_scores_combined_df$is_negative <- test_scores_combined_df$Protein %in% df_negative_control$Protein

# 2. Make predictions using the existing logistic model
predictions <- predict(logistic_model, newdata = test_scores_combined_df, type = "response")

# 3. Apply threshold (z. B. gleich wie oben: 0.3899612)
selected_proteins <- test_scores_combined_df[predictions > 0.3899612, ]

# 4. Count how many of the selected proteins are from the negative control
table(selected_proteins$is_negative)

# Optional: Extract those negative control proteins among predicted positives
predicted_negatives <- selected_proteins[selected_proteins$is_negative, ]

# Optional: Extract predicted hits that are NOT from the negative control
predicted_non_negative <- selected_proteins[!selected_proteins$is_negative, ]

```



```{r}
# filter proteins for significant right shift
filtered_df <- test_scores_combined_df[test_scores_combined_df$Shift_direction_ctrl_to_rnase == "right shift" & test_scores_combined_df$probability >= q3_pos_preds, ] 

# extract protein names from first column, save proteinnames as dataframe
right_shift_proteins_df <- data.frame(Protein = filtered_df[[1]])

# number of filtered proteins
right_shift_count <- nrow(filtered_df)

# depict results
print(right_shift_proteins_df)

print(paste("Anzahl der 'right shift'-Proteine mit Probability ≥ 0.3899612:", right_shift_count))

```


```{r}####################################
# Nur die Protein-Namen als Vektor
protein_names <- right_shift_proteins_df$Protein

# Schreibe sie zeilenweise in eine Textdatei
writeLines(protein_names, "right_shift_proteins.txt")
```

######PART 3
###Data reduction
```{r}
#pca trial 
 normal_rna_df <- normalized_rnase_df[,2:ncol(normalized_rnase_df)]
str(normal_rna_df)

```
```{r}
apply(normal_rna_df, 2, mean)
```

```{r}
apply(normal_rna_df, 2, sd)
```

```{r}
RNA_pca <- prcomp(normal_rna_df, center = TRUE, scale = TRUE)

names(RNA_pca)
```

```{r}
RNA_pca$rotation
```


```{r}
RNA_pca$sdev
```

```{r}
RNA_pca_var <- RNA_pca$sdev^2 # eigenvalues 
RNA_pca_var
```

```{r}
RNA_pca_ve <- round(RNA_pca_var / sum(RNA_pca_var)*100,2) # wert in prozent auf zwei dezimal 
RNA_pca_ve
```
```{r}
sort(RNA_pca_ve,decreasing=TRUE)
```

```{r}
barplot(RNA_pca_ve)
```




```{r}
biplot(RNA_pca, scale = 0, cex = 0.4)
```


```{r}
wss <- sapply(1:25, function(k){
  kmeans(RNA_pca$x, centers = k, nstart = 25)$tot.withinss
})

plot(1:25, wss, type = "b", pch = 19,
     xlab = "Anzahl der Cluster (k)",
     ylab = "Totale Within-Cluster-Varianz",
     main = "Elbow-Methode zur Bestimmung von k") 
```

```{r}
sil_width <- numeric(9)  # für k = 2 bis 10

for(k in 2:10) {
  km <- kmeans(RNA_pca, centers = k, nstart = 25)
  ss <- silhouette(km$cluster, dist(RNA_pca))
  sil_width[k - 1] <- mean(ss[, 3])  # Durchschnittliche Silhouette-Breite
}

plot(2:10, sil_width, type = "b", pch = 19,
     xlab = "Anzahl der Cluster (k)",
     ylab = "Durchschnittliche Silhouettenbreite",
     main = "Silhouettenanalyse zur Bestimmung von k")
```

```{r}
kmeans_result <- kmeans(RNA_pca$x, centers = 11, nstart = 25)
```

```{r}
kmeans_result$cluster    
kmeans_result$centers     
kmeans_result$tot.withinss
```

```{r}
pca_data <- as.data.frame(RNA_pca$x)
pca_data$cluster <- as.factor(kmeans_result$cluster)

library(ggplot2)

ggplot(pca_data, aes(x = PC1, y = PC2, color = cluster)) +
  geom_point(alpha = 0.7, size = 2) +
  labs(title = "K-Means Cluster im PCA-Raum",
       x = "Hauptkomponente 1 (PC1)",
       y = "Hauptkomponente 2 (PC2)") +
  theme_minimal() +
  scale_color_brewer(palette = "Set1")
```

```{r}
first_two_components <- RNA_pca$x[,1:2]
plot(first_two_components)
```

