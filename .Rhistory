par(mfrow = c(1, 2))
# PCA vor Korrektur
plot(pca_before$x[, 1:2],
col = rainbow(length(levels(batch)))[batch],
pch = 19,
main = "PCA vor Batch-Korrektur")
legend("topright", legend = levels(batch), col = rainbow(length(levels(batch))), pch = 19)
# PCA nach Korrektur
plot(pca_after$x[, 1:2],
col = rainbow(length(levels(batch)))[batch],
pch = 19,
main = "PCA nach Batch-Korrektur")
legend("topright", legend = levels(batch), col = rainbow(length(levels(batch))), pch = 19)
# Reset Layout
par(mfrow = c(1, 1))
# Optional: Wenn du pheatmap noch nicht hast
install.packages("pheatmap")
library(pheatmap)
# Auswahl einer Teilmenge der Proteine (z. B. Top 100 variabelsten)
select_top_var <- function(mat, top_n = 100) {
vars <- apply(mat, 1, var)
mat[order(vars, decreasing = TRUE)[1:top_n], ]
}
# Top 100 Gene mit höchster Varianz (vorher/nachher)
heat_before <- select_top_var(expr_matrix, 100)
heat_after  <- select_top_var(expr_corrected, 100)
# Spaltenannotation nach Batch
annotation_col <- data.frame(Batch = batch)
rownames(annotation_col) <- colnames(expr_matrix)
# Zwei Heatmaps nebeneinander
par(mfrow = c(1, 2))
pheatmap(heat_before,
main = "Heatmap vor Batch-Korrektur",
annotation_col = annotation_col,
show_rownames = FALSE,
cluster_cols = TRUE)
pheatmap(heat_after,
main = "Heatmap nach Batch-Korrektur",
annotation_col = annotation_col,
show_rownames = FALSE,
cluster_cols = TRUE)
# Reset Layout
par(mfrow = c(1, 1))
RNA_noBatch <- expr_corrected
head(RNA_noBatch)
knitr::opts_chunk$set(echo = TRUE)
#RDS-Daten laden
normalized_ctrl_df <- readRDS("data/normalized_ctrl_df.rds")
str(normalized_ctrl_df)
summary(normalized_ctrl_df)
# Nur erzeugen, wenn Datei noch nicht existiert
if (!file.exists("data/normalized_ctrl_df.rds")) {
message("HAAALT!!!! Speicher erst neuen Datensatz")
final_data <- data.frame(
normalized_ctrl_df
)
saveRDS(final_data, "data/normalized_ctrl_df.rds")
} else {
message("Datensatz existiert bereits")
}
normalized_rnase_df <- readRDS("data/normalized_rnase_df.rds")
str(normalized_rnase_df)
summary(normalized_rnase_df)
if (!file.exists("data/normalized_rnase_df.rds")) {
message("HAAALT!!!! Speicher erst neuen Datensatz")
final_data <- data.frame(
normalized_rnase_df
)
saveRDS(final_data, "data/normalized_rnase_df.rds")
} else {
message("Datensatz existiert bereits")
}
#limma install nicht notwendig wenn ihr es schon habt, führt zu doofen fehlern
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install(version = "3.21")
head(normalized_rnase_df)
dim(normalized_rnase_df)
expr_matrix <- normalized_rnase_df[, -1]
boxplot(expr_matrix,
main = "Proteinexpression pro Fraction",
ylab = "Expression",
xlab = "Fraction",
las = 2,
col = "lightblue")
batch_labels <- c(rep("Batch1", 3), rep("Batch2", 3), rep("Batch3", 3), rep("Batch4", 3), rep("Batch5", 3), rep("Batch6", 3), rep("Batch7", 4))
colors <- as.factor(batch_labels)
boxplot(expr_matrix,
main = "Expression nach Fraction (nach Batch gefärbt)",
ylab = "Expression",
xlab = "Fraction",
las = 2,
col = rainbow(length(unique(batch_labels)))[colors])
legend("topright", legend = unique(batch_labels), fill = rainbow(length(unique(batch_labels))), title = "Batch")
names(normalized_rnase_df)
#entfernen
library(limma)
batch <- c(rep("Batch1", 3),  # Fraction1-3
rep("Batch2", 3),  # Fraction4-6
rep("Batch3", 3),  # Fraction7-9
rep("Batch4", 3),  # Fraction10-12
rep("Batch5", 3),  # Fraction13-15
rep("Batch6", 3),  # Fraction16-18
rep("Batch7", 7))  # Fraction19-25
batch <- factor(batch)
# Expression-Matrix ohne Protein-Spalte
expr_matrix <- as.matrix(normalized_rnase_df[, -1])
expr_corrected <- removeBatchEffect(expr_matrix, batch = batch)
# Originaldaten
boxplot(expr_matrix,
main = "Vor Batch-Korrektur",
las = 2,
ylab = "Expression",
col = rainbow(length(batch))[batch])
# Nach Korrektur
boxplot(expr_corrected,
main = "Nach Batch-Korrektur (limma)",
las = 2,
ylab = "Expression",
col = rainbow(length(batch))[batch])
# PCA-Analyse vorbereiten
pca_before <- prcomp(t(expr_matrix), scale. = TRUE)
pca_after  <- prcomp(t(expr_corrected), scale. = TRUE)
# Batch-Zuordnung erneut für Farben
batch <- factor(c(rep("Batch1", 3), rep("Batch2", 3), rep("Batch3", 3),
rep("Batch4", 3), rep("Batch5", 3), rep("Batch6", 3), rep("Batch7", 7)))
# Plot nebeneinander
par(mfrow = c(1, 2))
# PCA vor Korrektur
plot(pca_before$x[, 1:2],
col = rainbow(length(levels(batch)))[batch],
pch = 19,
main = "PCA vor Batch-Korrektur")
legend("topright", legend = levels(batch), col = rainbow(length(levels(batch))), pch = 19)
# PCA nach Korrektur
plot(pca_after$x[, 1:2],
col = rainbow(length(levels(batch)))[batch],
pch = 19,
main = "PCA nach Batch-Korrektur")
legend("topright", legend = levels(batch), col = rainbow(length(levels(batch))), pch = 19)
# Reset Layout
par(mfrow = c(1, 1))
# Optional: Wenn du pheatmap noch nicht hast
install.packages("pheatmap")
library(pheatmap)
# Auswahl einer Teilmenge der Proteine (z. B. Top 100 variabelsten)
select_top_var <- function(mat, top_n = 100) {
vars <- apply(mat, 1, var)
mat[order(vars, decreasing = TRUE)[1:top_n], ]
}
# Top 100 Gene mit höchster Varianz (vorher/nachher)
heat_before <- select_top_var(expr_matrix, 100)
heat_after  <- select_top_var(expr_corrected, 100)
# Spaltenannotation nach Batch
annotation_col <- data.frame(Batch = batch)
rownames(annotation_col) <- colnames(expr_matrix)
# Zwei Heatmaps nebeneinander
par(mfrow = c(1, 2))
pheatmap(heat_before,
main = "Heatmap vor Batch-Korrektur",
annotation_col = annotation_col,
show_rownames = FALSE,
cluster_cols = TRUE)
pheatmap(heat_after,
main = "Heatmap nach Batch-Korrektur",
annotation_col = annotation_col,
show_rownames = FALSE,
cluster_cols = TRUE)
# Reset Layout
par(mfrow = c(1, 1))
RNA_noBatch <- expr_corrected
head(RNA_noBatch)
knitr::opts_chunk$set(echo = TRUE)
summary(cars)
plot(pressure)
#RDS-Daten laden
normalized_ctrl_df <- readRDS("data/normalized_ctrl_df.rds")
normalized_rnase_df <- readRDS("data/normalized_rnase_df.rds")
#visualize distribution for one protein -> hilft uns u.a. zu beurteilen ob Maxima-Funktion funktioniert
# Protein auswählen
protein_id <- "SPB6_HUMAN"
# extract amount of protein
intensities <- as.numeric(normalized_ctrl_df[4, 2:26 ])
fraktionen <- 1:25
# Plot
plot(fraktionen, intensities, type = "n",
xlab = "Fraktion (1–25)", ylab = "Normierte Intensität (Fläche = 1)",
main = paste("Dichte-Plot von", protein_id),
ylim = c(0, max(intensities)*1.1))
polygon(c(fraktionen, rev(fraktionen)),
c(rep(0, length(fraktionen)), rev(intensities)),
col = "lavender", border = NA)
lines(fraktionen, intensities, col = "lavender", lwd = 2)
#visualize distribution for one protein -> hilft uns u.a. zu beurteilen ob Maxima-Funktion funktioniert
# Protein auswählen
protein_id <- "SPB6_HUMAN"
# extract amount of protein
intensities <- as.numeric(normalized_ctrl_df[4, 2:26 ])
fraktionen <- 1:25
# Plot
plot(fraktionen, intensities, type = "n",
xlab = "Fraktion (1–25)", ylab = "Normierte Intensität (Fläche = 1)",
main = paste("Dichte-Plot von", protein_id),
ylim = c(0, max(intensities)*1.1))
polygon(c(fraktionen, rev(fraktionen)),
c(rep(0, length(fraktionen)), rev(intensities)),
col = "lavender", border = NA)
lines(fraktionen, intensities, col = "lavender", lwd = 2)
#find all maxima
# recognize peaks with diff()
find_peaks_diff <- function(x, threshold = 2) {
n <- length(x)
peaks <- logical(n)
dx <- diff(x)
# Interne Punkte prüfen: vorher steigend, danach fallend
for (i in 2:(n-1)) {
if (x[i] >= threshold && dx[i-1] > 0 && dx[i] < 0) {
peaks[i] <- TRUE
}
}
# Ränder prüfen
if (x[1] >= threshold && x[1] > x[2]) peaks[1] <- TRUE
if (x[n] >= threshold && x[n] > x[n-1]) peaks[n] <- TRUE
which(peaks)
}
# Beispielhafte Anwendung auf Dataframe mit Protein in Spalte 1 und 25 Messwerten in Spalten 2–26
process_df_peaks <- function(df, threshold = 2) {
results <- lapply(1:nrow(df), function(i) {
intensities <- as.numeric(df[i, 2:26])
protein <- df[i, 1]
peaks <- find_peaks_diff(intensities, threshold)
list(Protein = protein, Peaks = peaks)
})
# Ergebnis in Dataframe umwandeln: Peaks als kommaseparierte Liste oder NA, falls keine Peaks
df_peaks <- data.frame(
Protein = sapply(results, `[[`, "Protein"),
Maxima_Positions = sapply(results, function(x) {
if (length(x$Peaks) == 0) {
NA_character_
} else {
paste(x$Peaks, collapse = ",")
}
}),
stringsAsFactors = FALSE
)
return(df_peaks)
}
# apply to our dataframe
df_peaks_CTRL <- process_df_peaks(normalized_ctrl_df, threshold = 2)
df_peaks_RNAse <- process_df_peaks(normalized_rnase_df, threshold = 2)
# depict results
head(df_peaks_CTRL)
head(df_peaks_RNAse)
#find global maxima
find_global_maxima <- function(x, threshold = 2) {
max_val <- max(x)
if (max_val >= threshold) {
which(x == max_val)
} else {
integer(0)  # keine Maxima, falls max < threshold
}
}
process_df_global_maxima <- function(df, threshold = 2) {
results <- lapply(1:nrow(df), function(i) {
intensities <- as.numeric(df[i, 2:26])
protein <- df[i, 1]
maxima <- find_global_maxima(intensities, threshold)
list(Protein = protein, Global_Maxima = maxima)
})
df_maxima <- data.frame(
Protein = sapply(results, `[[`, "Protein"),
Global_Maximum = sapply(results, function(x) {
if (length(x$Global_Maxima) == 0) {
NA_character_
} else {
paste(x$Global_Maxima, collapse = ",")
}
}),
stringsAsFactors = FALSE
)
return(df_maxima)
}
#apply to dataframes
global_ctrl <- process_df_global_maxima(normalized_ctrl_df, threshold =2)
global_rnase <- process_df_global_maxima(normalized_rnase_df, threshold =2)
head(global_ctrl)
global_ctrl$Global_Maximum <- as.numeric(as.character(global_ctrl$Global_Maximum))
global_rnase$Global_Maximum <- as.numeric(as.character(global_rnase$Global_Maximum))
shift_distance <- global_rnase$Global_Maximum - global_ctrl$Global_Maximum
# Richtung bestimmen
shift_direction <- ifelse(shift_distance > 0, "right shift",
ifelse(shift_distance < 0, "left shift",
"No Shift"))
# Ergebnis zusammenfassen
shift_result <- data.frame(
Protein = global_ctrl$Protein,
Position_Control = global_ctrl$Global_Maximum,
Position_RNase = global_rnase$Global_Maximum,
Shift_Distance = shift_distance,
Shift_Direction = shift_direction
)
head(shift_result)
get_global_amplitudes <- function(expression_df, global_ctrl) {
amplitudes <- mapply(function(row_idx, max_pos_str) {
# max_pos_str kann mehrere Maxima enthalten, z.B. "5,10"
max_positions <- as.numeric(unlist(strsplit(max_pos_str, ",")))
if (length(max_positions) == 0 || all(is.na(max_positions))) {
return(NA)
}
# Intensitäten an den Maxima (Achtung: +1 wegen Proteinspalte in expression_df)
intensities <- as.numeric(expression_df[row_idx, max_positions + 1])
# Falls mehrere Maxima, alle Werte als String mit Komma trennen
paste(intensities, collapse = ",")
},
row_idx = 1:nrow(expression_df),
max_pos_str = as.character(global_ctrl$Global_Maximum)
)
data.frame(
Protein = expression_df[[1]],
Amplitudes = amplitudes,
stringsAsFactors = FALSE
)
}
global_amplitudes_ctrl <- get_global_amplitudes(normalized_ctrl_df, global_ctrl)
head(global_amplitudes_ctrl)
get_global_amplitudes <- function(expression_df, global_rnase) {
amplitudes <- mapply(function(row_idx, max_pos_str) {
# max_pos_str kann mehrere Maxima enthalten, z.B. "5,10"
max_positions <- as.numeric(unlist(strsplit(max_pos_str, ",")))
if (length(max_positions) == 0 || all(is.na(max_positions))) {
return(NA)
}
# Intensitäten an den Maxima (Achtung: +1 wegen Proteinspalte in expression_df)
intensities <- as.numeric(expression_df[row_idx, max_positions + 1])
# Falls mehrere Maxima, alle Werte als String mit Komma trennen
paste(intensities, collapse = ",")
},
row_idx = 1:nrow(expression_df),
max_pos_str = as.character(global_rnase$Global_Maximum)
)
data.frame(
Protein = expression_df[[1]],
Amplitudes = amplitudes,
stringsAsFactors = FALSE
)
}
global_amplitudes_rnase <- get_global_amplitudes(normalized_rnase_df, global_rnase)
head(global_amplitudes_rnase)
##Gain and loss of amplitude in peak
# Erst numerisch machen
global_amplitudes_ctrl$Amplitude <- as.numeric(as.character(global_amplitudes_ctrl$Amplitude))
global_amplitudes_rnase$Amplitude <- as.numeric(as.character(global_amplitudes_rnase$Amplitude))
# Verlust: Abnahme der Amplitude nach RNase-Behandlung
amplitude_loss <- pmax(global_amplitudes_ctrl$Amplitude - global_amplitudes_rnase$Amplitude, 0)
# Zuwachs: Zunahme der Amplitude nach RNase-Behandlung
amplitude_gain <- pmax(global_amplitudes_rnase$Amplitude - global_amplitudes_ctrl$Amplitude, 0)
amplitude_changes <- data.frame(
Protein = global_amplitudes_ctrl$Protein,
Amplitude_Control = global_amplitudes_ctrl$Amplitude,
Amplitude_RNase = global_amplitudes_rnase$Amplitude,
loss = amplitude_loss,
gain = amplitude_gain
)
head(amplitude_changes)
###Addition of all amplitude changes
amplitude_changes$changes <- amplitude_changes$loss + amplitude_changes$gain
amplitude_changes$changes_in25 <- (amplitude_changes$changes/100)*25
head(amplitude_changes)
# Join beider Dataframes mit globalen Maxima
df_diff_peaks <- shift_result[, 1:3]
# Differenz berechnen (neue Spalte 'diff')
df_diff_peaks$diff <- df_diff_peaks$Position_RNase - df_diff_peaks$Position_Control
# Achsenlimit berechnen
max_val <- max(
df_diff_peaks$Position_RNase,
df_diff_peaks$Position_Control,
na.rm= TRUE
)*1.1
# Farben für Punkte definieren
colors <- ifelse(df_diff_peaks$diff > 0, "pink",
ifelse(df_diff_peaks$diff < 0, "lavender", "cyan"))
# Scatterplot erstellen
plot(
df_diff_peaks$Position_RNase,
df_diff_peaks$Position_Control,
xlim = c(0, max_val),
ylim = c(0, max_val),
xlab = "Globales Maximum RNase",
ylab = "Globales Maximum Kontroll",
main = "Vergleich der globalen Maxima der Proteine",
pch = 19,
col = colors
)
# Diagonale Referenzlinie y = x
abline(a = 0, b = 1, col = "grey",lty=2)
## right shift proteins
# create dataframe with proteins and their shift direction
shift_df <- data.frame(
Proteins = normalized_ctrl_df$Protein,
Shift = shift_result$Shift_Direction
)
# sort all right shift proteins in one dataframe
right_shift_df <- shift_df[shift_df$Shift == "right shift", ]
head(right_shift_df)
dim(right_shift_df)
install.packages("emdist")
library(emdist)
# Custom function to compute 1D Earth Mover's Distance
compute_emd_1d <- function(vec1, vec2) {
# Remove NAs
vec1 <- as.numeric(na.omit(vec1))
vec2 <- as.numeric(na.omit(vec2))
# Ensure both vectors have the same length
if (length(vec1) != length(vec2)) {
return(NA)
}
# Normalize both vectors to sum to 1 (as probability distributions)
vec1 <- vec1 / sum(vec1)
vec2 <- vec2 / sum(vec2)
# Compute cumulative distributions
cdf1 <- cumsum(vec1)
cdf2 <- cumsum(vec2)
# EMD in 1D is the sum of absolute differences of CDFs
emd <- sum(abs(cdf1 - cdf2))
return(emd)
}
# Vector to store EMD results
emd_values <- numeric(nrow(normalized_ctrl_df))
# Loop through all proteins (rows)
for (i in 1:nrow(normalized_ctrl_df)) {
# Extract fraction profiles (columns 2 to 26)
vec_ctrl <- as.numeric(normalized_ctrl_df[i, 2:26])
vec_rnase <- as.numeric(normalized_rnase_df[i, 2:26])
# Compute 1D EMD
emd_values[i] <- compute_emd_1d(vec_ctrl, vec_rnase)
}
# Add EMD results as a new column to the data frame
normalized_ctrl_df$EMD <- emd_values
normalized_rnase_df$EMD <- emd_values  # Optional, for consistency (values are the same as for Ctrl)
#EMD results can potentially range from 0 (Ctrl and RNase are identical) to 25 (Ctrl and RNase are as dissimilar as they can be)
# depict results
head(normalized_ctrl_df[, c(1, 27)])  # Show protein name and EMD
#define dataframe for all test scores of all proteines
print(normalized_ctrl_df$EMD)
test_scores_combined_df <- data.frame(
Protein = normalized_ctrl_df$Protein,
Shift_Distance_ctrl_to_rnase = shift_result$Shift_Distance,
Shift_direction_ctrl_to_rnase = shift_result$Shift_Direction,
amplitude_changes = amplitude_changes$changes_in25,
EMD = normalized_ctrl_df$EMD
)
head(test_scores_combined_df)
# load dataframe for t-test
percent_ctrl_df <- readRDS("data/percent_ctrl_df.rds")
percent_rnase_df <- readRDS("data/percent_rnase_df.rds")
# install and load package
install.packages("DT")
library(DT)
# read data
url <- "https://raw.githubusercontent.com/MichelaPozzi/2025-topic-03-group-04/main/table_RBP_lists.csv"
lines <- readLines(url, encoding = "UTF-8")
header <- unlist(strsplit(lines[6], ","))
data <- read.csv(text = lines[7:length(lines)], header = FALSE, sep = ",", stringsAsFactors = FALSE)
colnames(data) <- header
# depict datatable
datatable(data, filter = "top", options = list(pageLength = 25))
# save dataframe locally
write.csv(data, "mein_ergebnis.csv", row.names = FALSE)
#save result as dataframe
RBP_resources <- as.data.frame(data)
#depict result
head(RBP_resources)
#identify proteins which can potentially be used as negative control
# proteins which were identified as RDPs not more than once
RNA_independent <- RBP_resources[RBP_resources[,4] %in% c(0,1), , drop = FALSE]
# depict result
head(RNA_independent)
# check which of the potential proteins for negative control are actually contained in our dataset
row_subset <- RNA_independent[,1]
ref_row <- normalized_ctrl_df[,1]
# find common proteins
common_proteins_negative <- intersect(row_subset, ref_row)
# depict vector with common proteins
length(common_proteins_negative)
# 400 zufällige Elemente aus 'mein_vektor' ziehen (ohne Zurücklegen)
negative_control <- sample(common_proteins_negative, 550, replace = FALSE)
length(negative_control)
# create dataframe negative control
# extract corresponding proteins from test_scores_combined_df
df_negative_control <- test_scores_combined_df[test_scores_combined_df$Protein %in% negative_control, ]
# depict result
print(df_negative_control)
#identify proteins which can potentially be used as positive control
RNA_dependent <- RBP_resources[RBP_resources[,4] %in% c(8, 9, 10, 11, 12, 13, 14, 15,16, 17, 18), , drop = FALSE]
#depict result
head(RNA_dependent)
#check which of the potential proteins for negative control are actually contained in our dataset
row_subset <- RNA_dependent[,1]
ref_row <- normalized_ctrl_df[,1]
# find common proteins
common_proteins_positive <- intersect(row_subset, ref_row)
# Ausgabe des Vektors mit gemeinsamen Proteinen
length(common_proteins_positive)
# 400 zufällige Elemente aus 'mein_vektor' ziehen (ohne Zurücklegen)
positive_control <- sample(common_proteins_positive, 550, replace = FALSE)
length(positive_control)
# create dataframe positive control
# extract corresponding proteins from test_scores_combined_df
df_positive_control <- test_scores_combined_df[test_scores_combined_df$Protein %in% positive_control, ]
# depict result
print(df_positive_control)
install.packages("DT")
