for (j in 2:25) {
df_new_rnase[, col_idx[j]] <- df_rnase[, col_idx[j]] * factors[j]
}
}
#depict result
head(df_new_rnase)
# Mean filter function for a row (preserving first and last value)
mean_filter <- function(x) {
n <- length(x)
y <- numeric(n)
y[1] <- x[1] #first value will not be changed (e.g. Fraction1_Rep1)
y[n] <- x[n] #last value will not be changed (e.g. Fraction25_Rep1)
y[2:(n-1)] <- sapply(2:(n - 1), function(i) mean(x[(i - 1):(i + 1)])) #creates filter masks
return(y)
}
# Function to apply the filter block-wise
apply_mean_filter_blocks <- function(df, starts, block_size = 25) {
df_filtered <- df
for (start_col in starts) {
cols <- start_col:(start_col + block_size - 1)
df_filtered[, cols] <- t(apply(df[, cols], 1, mean_filter))
}
return(df_filtered)
}
# Define block starts
starts <- c(2, 27, 52)
# Apply to both datasets
ctrl_filtered  <- apply_mean_filter_blocks(df_new_ctrl,   starts)
rnase_filtered <- apply_mean_filter_blocks(df_new_rnase,  starts)
# Show results
head(ctrl_filtered)
head(rnase_filtered)
#normalize total amount per replicate to 100%
# Function to normalize rows to 100% within column blocks
normalize_blocks <- function(df, starts, block_size = 25) {
df_norm <- df  # create a copy of the dataframe
for (start_col in starts) {
end_col <- start_col + block_size - 1 #(e.g. 1 + 25 - 1 = 25 )
cols <- start_col:end_col
block <- df[, cols]  # extract block of columns
block_norm <- block * 100 / rowSums(block, na.rm = TRUE)  # normalize row sums to 100%
df_norm[, cols] <- block_norm  # replace original block with normalized block
}
return(df_norm)
}
# Define starting points of each replicate block
starts <- c(2, 27, 52)
# Apply the function to both datasets
ctrl_norm_percent  <- normalize_blocks(ctrl_filtered,  starts)
rnase_norm_percent <- normalize_blocks(rnase_filtered, starts)
# depict result
head(ctrl_norm_percent)
head(rnase_norm_percent)
# check if row sums per block are ~100
summary(rowSums(ctrl_norm_percent[, 2:26]))
summary(rowSums(rnase_norm_percent[, 2:26]))
#sorts normalized dataframes by fraction
# define columnnames
col_names_ctrl <- colnames(ctrl_norm_percent)
col_names_rnase <- colnames(rnase_norm_percent)
# 1. save proteinnames column separately
protein_col_ctrl <- ctrl_norm_percent[, 1, drop = FALSE]
protein_col_rnase <- rnase_norm_percent[, 1, drop = FALSE]
# 2. define columnnames without the first column
cols_to_sort_ctrl <- col_names_ctrl[-1]
cols_to_sort_rnase <- col_names_rnase[-1]
# 3. extract fraction number
fraction_num_ctrl <- as.numeric(gsub(".*Fraction([0-9]+).*", "\\1", cols_to_sort_ctrl))
fraction_num_rnase <- as.numeric(gsub(".*Fraction([0-9]+).*", "\\1", cols_to_sort_rnase))
# 4. extract replicate number
rep_num_ctrl <- as.numeric(gsub(".*Rep([0-9]+).*", "\\1", cols_to_sort_ctrl))
rep_num_rnase <- as.numeric(gsub(".*Rep([0-9]+).*", "\\1", cols_to_sort_rnase))
# 5. define sorting order
order_index_ctrl <- order(fraction_num, rep_num_ctrl)
knitr::opts_chunk$set(echo = TRUE)
#load dataset
url <- "https://hub.dkfz.de/s/QT3BfRperQqMxPF/download/RDeeP_A549_NS.csv.zip"
#Create a temporary file and download the ZIP
temp_file <- tempfile()
download.file(url, temp_file)
zip_contents <- unzip(temp_file, list = TRUE)
print(zip_contents)
csv_file <- unzip(temp_file, files = zip_contents$Name[1], exdir = tempdir())
A549_NS <- read.csv(csv_file, sep = ";")
View(A549_NS)
#data exploration
View(A549_NS)
#number of rows and columns
nrow(A549_NS)
ncol(A549_NS)
#type of data (überprüft die class der Spalten -> alle Eintrage haben zwangsweise dieselbe class)
sum(sapply(A549_NS, is.numeric))
#finding NAs
sum(is.na(A549_NS))
#definition of general parameters
n_fractions <- 25
n_replicates <- 6
# treatment: variating CTRL and RNAse, 75 pairs -> 150 columns
treatment <- factor(rep(c("CTRL", "RNASE"), times = n_fractions * n_replicates/2))
# replicates: 6 replicates per fraction
replicates <- factor(c("ctrl1","rnase1","ctrl2","rnase2","ctrl3","rnase3"))
replicates <- factor(rep(replicates, times = n_fractions))
# fraction: each fraction has 6 values
fraction <- factor(rep(paste0("fraction",1:n_fractions),each = n_replicates))
#dataframe definition
df <- data.frame(
row.names = colnames(A549_NS)[colnames(A549_NS) != "Protein_Name"],
treatment = treatment,
replicates = replicates,
fraction = fraction)
#depict result
head(df)
#sorting loop by fraction
# define fraction names
fraction_names <- levels(fraction)
# create subtables
tables_by_fraction <- lapply(fraction_names, function(fx) {
# select all colnames in A549_NS, which belong to a certain fraction
cols <- rownames(df)[df$fraction == fx]
#separate control and RNase sample within the subtable (grep-function searches for the word "Ctrl" or "RNase among the columnnames -> generally searches for textpatterns in vectors)
ctrl_cols <- grep("Ctrl",cols, value = TRUE)
RNase_cols <- grep("RNase",cols, value = TRUE)
ordered_cols <- c(ctrl_cols, RNase_cols)
# extract the said columns + Protein_Name
subdf <- A549_NS[, c("Protein_Name", ordered_cols)]
})
# assign names to the subtables -> names of fractions are assigned to the different subtables in chronological order
names(tables_by_fraction) <- fraction_names
#depict result
head(tables_by_fraction$fraction1)
class(tables_by_fraction$fraction1)
#reproducability
#geordnete Tabelle
length(tables_by_fraction)
print(tables_by_fraction)
protein_names <- tables_by_fraction[[1]]$Protein_Name
table_list_no_names <- lapply(tables_by_fraction, function(x) x[, -1])
# Spaltenweise zusammenfügen
ordered_table <- do.call(cbind, table_list_no_names)
# Protein_Name wieder hinzufügen
ordered_table <- cbind(Protein_Name = protein_names, ordered_table)
ordered_table <- as.data.frame(ordered_table, check.names = FALSE)
print(ordered_table)
ctrl_correlations <- data.frame(
fraction = character(),
ctrl1_vs_ctrl2 = numeric(),
ctrl1_vs_ctrl3 = numeric(),
ctrl2_vs_ctrl3 = numeric(),
stringsAsFactors = FALSE
)
# Schleife über alle 25 Fraktionen
for (i in 0:24) {
start_col <- 2 + i * 6
end_col <- start_col + 2
ctrl_data <- ordered_table[, start_col:end_col]
colnames(ctrl_data) <- c("ctrl1", "ctrl2", "ctrl3")
cor_matrix <- cor(ctrl_data, use = "pairwise.complete.obs", method = "pearson")
ctrl_correlations <- rbind(ctrl_correlations, data.frame(
fraction = paste0("fraction", i + 1),
ctrl1_vs_ctrl2 = cor_matrix["ctrl1", "ctrl2"],
ctrl1_vs_ctrl3 = cor_matrix["ctrl1", "ctrl3"],
ctrl2_vs_ctrl3 = cor_matrix["ctrl2", "ctrl3"]
))
}
# Ergebnis ansehen
View(ctrl_correlations)
plot(ctrl_correlations)
##nochmal mit RNase Korrelation
rnase_correlations <- data.frame(
fraction = character(),
rnase1_vs_rnase2 = numeric(),
rnase1_vs_rnase3 = numeric(),
rnase2_vs_rnase3 = numeric(),
stringsAsFactors = FALSE
)
# Schleife über alle 25 Fraktionen
for (i in 0:24) {
start_col <- 2 + i * 6
end_col <- start_col + 2
rnase_data <- ordered_table[, start_col:end_col]
colnames(rnase_data) <- c("rnase1", "rnase2", "rnase3")
cor_matrix <- cor(rnase_data, use = "pairwise.complete.obs", method = "pearson")
rnase_correlations <- rbind(rnase_correlations, data.frame(
fraction = paste0("fraction", i + 1),
rnase1_vs_rnase2 = cor_matrix["rnase1", "rnase2"],
rnase1_vs_rnase3 = cor_matrix["rnase1", "rnase3"],
rnase2_vs_rnase3 = cor_matrix["rnase2", "rnase3"]
))
}
View(rnase_correlations)
#facilitates access to different fractions
df_list <- list()
for (a in 1:25) {
df_list[[a]] <- as.data.frame(tables_by_fraction[[paste0("fraction", a)]])
}
#depict result
head(df_list[[1]])
class(df_list[[1]])
# Function to extract and sort columns by condition and replicate
get_ordered_columns <- function(df, condition, replicates) {
col_names <- colnames(df)
condition_cols <- grep(condition, col_names, value = TRUE)
# Sort by replicate order
sorted_cols <- unlist(lapply(replicates, function(rep) {
grep(rep, condition_cols, value = TRUE)
}))
return(sorted_cols)
}
# Define replicates
replicates <- c("Rep1", "Rep2", "Rep3")
# Get ordered columns
ctrl_ordered_cols <- get_ordered_columns(A549_NS, "Ctrl", replicates)
rnase_ordered_cols <- get_ordered_columns(A549_NS, "RNase", replicates)
# Subset and include "Protein_Name"
df_ctrl <- A549_NS[, c("Protein_Name", ctrl_ordered_cols), drop = FALSE]
df_rnase <- A549_NS[, c("Protein_Name", rnase_ordered_cols), drop = FALSE]
# Preview results
head(df_ctrl)
head(df_rnase)
#create separate sublists for Ctrl and RNase per fraction and computes column-wise means
ctrl_list <- list()
rnase_list <- list()
for (r in 1:25) {
# defines access to the different fractions
df <- df_list[[r]]
# only takes numeric columns into account
numeric_df <- df[, sapply(df, is.numeric)]
# computes averages by. column
avg_vector <- colMeans(numeric_df)
# transform result to dataframe
avg_df <- as.data.frame(t(avg_vector))
# adds column with fraction name
fraction_label <- paste0("fraction", r)
# creates separate dataframes for Ctrl and RNase per Fraktion
ctrl_df <- avg_df[, 1:3]  # Crtl replicates make up the first three columns of avg_df
ctrl_df$fraction <- fraction_label
rnase_df <- avg_df[, 4:6]  # RNase makes up columns 4 to 6
rnase_df$fraction <- fraction_label
# rename columns
colnames(ctrl_df) <- c("Mean_CTRL1", "Mean_CTRL2", "Mean_CTRL3", "fraction")
colnames(rnase_df) <- c("Mean_RNASE1", "Mean_RNASE2", "Mean_RNASE3", "fraction")
# save columns in respective lists
ctrl_list[[r]] <- ctrl_df
rnase_list[[r]] <- rnase_df
}
# create to dataframes which contain the averages for all fractions
ctrl_combined <- do.call(rbind, ctrl_list)
rnase_combined <- do.call(rbind, rnase_list)
# depict result
head(ctrl_combined)
head(rnase_combined)
# determine the mean of the two closest replicate means
# function: mean of the two closest means (of 3 means per treatment)
mean_of_closest_pair <- function(x) {
combs <- combn(x, 2)
diffs <- abs(combs[1, ] - combs[2, ])
min_idx <- which.min(diffs)
mean(combs[, min_idx])
}
# initialize result vectors
final_means_control <- numeric(n_fractions)
final_means_rnase <- numeric(n_fractions)
# loop over all 25 fractions
for (r in 1:n_fractions) {
# access replicate means of control and RNase
control_values <- as.numeric(ctrl_combined[r, 1:3])
rnase_values   <- as.numeric(rnase_combined[r, 1:3])
# compution of the final means
final_means_control[r] <- mean_of_closest_pair(control_values)
final_means_rnase[r]   <- mean_of_closest_pair(rnase_values)
}
# generate a dataframe with both treatment means per fraction
final_means_df <- data.frame(
fraction = 1:length(final_means_control),
control_mean = final_means_control,
rnase_mean = final_means_rnase)
# depict results/dataframe
head(final_means_control)
head(final_means_rnase)
head(final_means_df)
# compute normalization vectors for each replicate
# number of fractions and replicates
n_fractions <- 25
n_replicates <- 3
# initialize matrizes for saving the normalizationfacotrs
norm_ctrl_mat <- matrix(NA, nrow = n_fractions, ncol = n_replicates)
norm_rnase_mat <- matrix(NA, nrow = n_fractions, ncol = n_replicates)
# loop over all fractions
for (r in 1:n_fractions) {
# extract values of the replicates
control_values <- as.numeric(ctrl_combined[r, 1:3])
rnase_values   <- as.numeric(rnase_combined[r, 1:3])
# define final_means of the treatments
mean_control <- final_means_control[r]
mean_rnase   <- final_means_rnase[r]
# compute normalization factors
norm_ctrl_mat[r, ] <- control_values / mean_control
norm_rnase_mat[r, ] <- rnase_values / mean_rnase
}
# create vectors for each replicate
norm.ctrl1 <- norm_ctrl_mat[, 1]
norm.ctrl2 <- norm_ctrl_mat[, 2]
norm.ctrl3 <- norm_ctrl_mat[, 3]
norm.rnase1 <- norm_rnase_mat[, 1]
norm.rnase2 <- norm_rnase_mat[, 2]
norm.rnase3 <- norm_rnase_mat[, 3]
# depict results
head(norm.ctrl1)
head(norm.ctrl2)
head(norm.ctrl3)
head(norm.rnase1)
head(norm.rnase2)
head(norm.rnase3)
# normalization of the data per replicate & fraction -> stimmt so nicht, glaube ich !!!!!!!!
# initialize empty lists for the normalized tables
norm_ctrl_list <- list()
norm_rnase_list <- list()
# loop over all fractions
for (r in 1:n_fractions) {
# use only the first three columns of the dataframes (the last   column contains rownames)
ctrl_df <- ctrl_combined[r, 1:3] ####müssten Originaldaten sein!!!!!!!
rnase_df <- rnase_combined[r, 1:3]
# get the corresponding normalization factors for each fraction
norm_factors_ctrl <- norm_ctrl_mat[r, ]
norm_factors_rnase <- norm_rnase_mat[r, ]
# apply normalization
norm_ctrl <- as.data.frame(mapply(`*`, ctrl_df, norm_factors_ctrl, SIMPLIFY = FALSE))
norm_rnase <- as.data.frame(mapply(`*`, rnase_df, norm_factors_rnase, SIMPLIFY = FALSE))
# save in lists
norm_ctrl_list[[r]] <- norm_ctrl
norm_rnase_list[[r]] <- norm_rnase
}
# optional: combine to one df per treatment
norm_ctrl_combined <- do.call(rbind, norm_ctrl_list)
norm_rnase_combined <- do.call(rbind, norm_rnase_list)
# depict result
head(norm_ctrl_combined)
head(norm_rnase_combined)
#normalization of the data per replicate & fraction for Ctrl
#Orignal dataframe that is ordered by condition and replicates is used
# results should have same dimensions as df_ctrl
df_new_ctrl <- df_ctrl
# for each column of the normalization factor matrix
for (i in 1:3) {
# matching column range in original data frame
col_idx <- ((i - 1) * 25 + 1):(i * 25)
# factor vector: creates vector for each column
factors <- norm_ctrl_combined[, i]
# multiply column with its factor
for (j in 2:25) {
df_new_ctrl[, col_idx[j]] <- df_ctrl[, col_idx[j]] * factors[j]
}
}
#depict result
head(df_new_ctrl)
#normalization of the data per replicate & fraction for Ctrl
#Orignal dataframe that is ordered by condition and replicates is used
# results should have same dimensions as df_ctrl
df_new_rnase <- df_rnase
# for each column of the normalization factor matrix
for (i in 1:3) {
# matching column range in original data frame
col_idx <- ((i - 1) * 25 + 1):(i * 25)
# factor vector: creates vector for each column
factors <- norm_rnase_combined[, i]
# multiply column with its factor
for (j in 2:25) {
df_new_rnase[, col_idx[j]] <- df_rnase[, col_idx[j]] * factors[j]
}
}
#depict result
head(df_new_rnase)
# Mean filter function for a row (preserving first and last value)
mean_filter <- function(x) {
n <- length(x)
y <- numeric(n)
y[1] <- x[1] #first value will not be changed (e.g. Fraction1_Rep1)
y[n] <- x[n] #last value will not be changed (e.g. Fraction25_Rep1)
y[2:(n-1)] <- sapply(2:(n - 1), function(i) mean(x[(i - 1):(i + 1)])) #creates filter masks
return(y)
}
# Function to apply the filter block-wise
apply_mean_filter_blocks <- function(df, starts, block_size = 25) {
df_filtered <- df
for (start_col in starts) {
cols <- start_col:(start_col + block_size - 1)
df_filtered[, cols] <- t(apply(df[, cols], 1, mean_filter))
}
return(df_filtered)
}
# Define block starts
starts <- c(2, 27, 52)
# Apply to both datasets
ctrl_filtered  <- apply_mean_filter_blocks(df_new_ctrl,   starts)
rnase_filtered <- apply_mean_filter_blocks(df_new_rnase,  starts)
# Show results
head(ctrl_filtered)
head(rnase_filtered)
#normalize total amount per replicate to 100%
# Function to normalize rows to 100% within column blocks
normalize_blocks <- function(df, starts, block_size = 25) {
df_norm <- df  # create a copy of the dataframe
for (start_col in starts) {
end_col <- start_col + block_size - 1 #(e.g. 1 + 25 - 1 = 25 )
cols <- start_col:end_col
block <- df[, cols]  # extract block of columns
block_norm <- block * 100 / rowSums(block, na.rm = TRUE)  # normalize row sums to 100%
df_norm[, cols] <- block_norm  # replace original block with normalized block
}
return(df_norm)
}
# Define starting points of each replicate block
starts <- c(2, 27, 52)
# Apply the function to both datasets
ctrl_norm_percent  <- normalize_blocks(ctrl_filtered,  starts)
rnase_norm_percent <- normalize_blocks(rnase_filtered, starts)
# depict result
head(ctrl_norm_percent)
head(rnase_norm_percent)
# check if row sums per block are ~100
summary(rowSums(ctrl_norm_percent[, 2:26]))
summary(rowSums(rnase_norm_percent[, 2:26]))
#sorts normalized dataframes by fraction
# define columnnames
col_names_ctrl <- colnames(ctrl_norm_percent)
col_names_rnase <- colnames(rnase_norm_percent)
# 1. save proteinnames column separately
protein_col_ctrl <- ctrl_norm_percent[, 1, drop = FALSE]
protein_col_rnase <- rnase_norm_percent[, 1, drop = FALSE]
# 2. define columnnames without the first column
cols_to_sort_ctrl <- col_names_ctrl[-1]
cols_to_sort_rnase <- col_names_rnase[-1]
# 3. extract fraction number
fraction_num_ctrl <- as.numeric(gsub(".*Fraction([0-9]+).*", "\\1", cols_to_sort_ctrl))
fraction_num_rnase <- as.numeric(gsub(".*Fraction([0-9]+).*", "\\1", cols_to_sort_rnase))
# 4. extract replicate number
rep_num_ctrl <- as.numeric(gsub(".*Rep([0-9]+).*", "\\1", cols_to_sort_ctrl))
rep_num_rnase <- as.numeric(gsub(".*Rep([0-9]+).*", "\\1", cols_to_sort_rnase))
# 5. define sorting order
order_index_ctrl <- order(fraction_num, rep_num_ctrl)
##nochmal mit RNase Korrelation
rnase_correlations <- data.frame(
fraction = character(),
rnase1_vs_rnase2 = numeric(),
rnase1_vs_rnase3 = numeric(),
rnase2_vs_rnase3 = numeric(),
stringsAsFactors = FALSE
)
# Schleife über alle 25 Fraktionen
for (i in 0:24) {
start_col <- 5 + i * 6
end_col <- start_col + 2
rnase_data <- ordered_table[, start_col:end_col]
colnames(rnase_data) <- c("rnase1", "rnase2", "rnase3")
cor_matrix <- cor(rnase_data, use = "pairwise.complete.obs", method = "pearson")
rnase_correlations <- rbind(rnase_correlations, data.frame(
fraction = paste0("fraction", i + 1),
rnase1_vs_rnase2 = cor_matrix["rnase1", "rnase2"],
rnase1_vs_rnase3 = cor_matrix["rnase1", "rnase3"],
rnase2_vs_rnase3 = cor_matrix["rnase2", "rnase3"]
))
}
View(rnase_correlations)
ctrl_correlations <- data.frame(
fraction = character(),
ctrl1_vs_ctrl2 = numeric(),
ctrl1_vs_ctrl3 = numeric(),
ctrl2_vs_ctrl3 = numeric(),
stringsAsFactors = FALSE
)
# Schleife über alle 25 Fraktionen
for (i in 0:24) {
start_col <- 2 + i * 6
end_col <- start_col + 2
ctrl_data <- ordered_table[, start_col:end_col]
colnames(ctrl_data) <- c("ctrl1", "ctrl2", "ctrl3")
cor_matrix <- cor(ctrl_data, use = "pairwise.complete.obs", method = "pearson")
ctrl_correlations <- rbind(ctrl_correlations, data.frame(
fraction = paste0("fraction", i + 1),
ctrl1_vs_ctrl2 = cor_matrix["ctrl1", "ctrl2"],
ctrl1_vs_ctrl3 = cor_matrix["ctrl1", "ctrl3"],
ctrl2_vs_ctrl3 = cor_matrix["ctrl2", "ctrl3"]
))
}
# Ergebnis ansehen
View(ctrl_correlations)
plot(ctrl_correlations)
##FRAKTION 22
##nochmal mit RNase Korrelation
rnase_correlations <- data.frame(
fraction = character(),
rnase1_vs_rnase2 = numeric(),
rnase1_vs_rnase3 = numeric(),
rnase2_vs_rnase3 = numeric(),
stringsAsFactors = FALSE
)
# Schleife über alle 25 Fraktionen
for (i in 0:24) {
start_col <- 5 + i * 6
end_col <- start_col + 2
rnase_data <- ordered_table[, start_col:end_col]
colnames(rnase_data) <- c("rnase1", "rnase2", "rnase3")
cor_matrix <- cor(rnase_data, use = "pairwise.complete.obs", method = "pearson")
rnase_correlations <- rbind(rnase_correlations, data.frame(
fraction = paste0("fraction", i + 1),
rnase1_vs_rnase2 = cor_matrix["rnase1", "rnase2"],
rnase1_vs_rnase3 = cor_matrix["rnase1", "rnase3"],
rnase2_vs_rnase3 = cor_matrix["rnase2", "rnase3"]
))
}
View(rnase_correlations)
plot(rnase_correlations)
