show_rownames = FALSE,
cluster_cols = TRUE)
pheatmap(heat_after,
main = "Heatmap nach Batch-Korrektur",
annotation_col = annotation_col,
show_rownames = FALSE,
cluster_cols = TRUE)
# Reset Layout
par(mfrow = c(1, 1))
install.packages("pheatmap")
# 1. Matrix mit Expressionswerten extrahieren (ohne Protein-Spalte)
expr_matrix <- as.matrix(final_smoothed_ctrl_df[, -1])
# 2. Sample-Namen extrahieren
sample_names <- colnames(expr_matrix)
# 3. Batch-Labels aus Sample-Namen ziehen (Rep1, Rep2, Rep3)
batch <- sub(".*_(Rep\\d)", "\\1", sample_names)
batch <- factor(batch, levels = c("Rep1", "Rep2", "Rep3"))
# 4. Farben zuordnen
batch_colors <- c("Rep1" = "red", "Rep2" = "green", "Rep3" = "blue")
colors <- batch_colors[as.character(batch)]
# 5. Boxplot zeichnen
boxplot(expr_matrix,
main = "Expression nach Sample (Batch gefärbt)",
ylab = "Expression",
xlab = "Samples",
las = 2,                      # X-Achse: senkrechte Labels
col = colors,
outline = FALSE,
cex.axis = 0.6)              # kleinere Achsenbeschriftung
# 6. Legende hinzufügen
legend("topright",
legend = names(batch_colors),
fill = batch_colors,
title = "Batch")
library(limma)
# 1. Matrix mit Expressionswerten extrahieren (ohne Protein-Spalte)
expr_matrix <- as.matrix(final_smoothed_ctrl_df[, -1])
# 2. Sample-Namen extrahieren
sample_names <- colnames(expr_matrix)
# 3. Batch-Labels aus Sample-Namen ziehen (Rep1, Rep2, Rep3)
batch <- sub(".*_(Rep\\d)", "\\1", sample_names)
batch <- factor(batch, levels = c("Rep1", "Rep2", "Rep3"))
# 4. Log2-Transformation (falls nötig, empfohlen wegen Skalenproblem)
expr_matrix_log <- log2(expr_matrix + 1)
# 5. Batch-Korrektur mit limma
expr_corrected <- removeBatchEffect(expr_matrix_log, batch = batch)
# 5. Boxplot zeichnen vor korrektur
boxplot(expr_matrix,
main = "Expression vor Korrektur (Batch gefärbt)",
ylab = "Expression",
xlab = "Samples",
las = 2,                      # X-Achse: senkrechte Labels
col = colors,
outline = FALSE,
cex.axis = 0.6)              # kleinere Achsenbeschriftung
# Boxplot nach Korrektur
boxplot(expr_corrected,
main = "Expression nach Korrektur (Batch gefärbt)",
ylab = "Expression",
xlab = "Samples",
las = 2,                      # X-Achse: senkrechte Labels
col = colors,
outline = FALSE,
cex.axis = 0.6)              # kleinere Achsenbeschriftung
# 6. Legende hinzufügen
legend("topright",
legend = names(batch_colors),
fill = batch_colors,
title = "Batch")
head(expr_corrected)
knitr::opts_chunk$set(echo = TRUE)
#RDS-Daten laden
final_smoothed_ctrl_df <- readRDS("data/final_smoothed_ctrl.rds")
str(final_smoothed_ctrl_df)
summary(final_smoothed_ctrl_df)
# Nur erzeugen, wenn Datei noch nicht existiert
if (!file.exists("data/final_smoothed_ctrl.rds")) {
message("HAAALT!!!! Speicher erst neuen Datensatz")
final_data <- data.frame(
final_smoothed_ctrl_df
)
saveRDS(final_data, "data/final_smoothed_ctrl.rds")
} else {
message("Datensatz existiert bereits")
}
head(final_smoothed_ctrl_df)
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("sva")
colnames(final_smoothed_ctrl_df)
# Angenommen das hier sind deine Spaltennamen
samples <- colnames(exprs)[-1]  # -1 entfernt "Protein"
# sampleInfo automatisch extrahieren
sampleInfo <- data.frame(
Sample = samples,
Fraction = as.numeric(sub("Fraction(\\d+)_Rep\\d", "\\1", samples)),
Batch = sub("Fraction\\d+_(Rep\\d)", "\\1", samples)
)
# Angenommen das hier sind deine Spaltennamen
samples <- colnames(final_smoothed_ctrl_df)[-1]  # -1 entfernt "Protein"
# sampleInfo automatisch extrahieren
sampleInfo <- data.frame(
Sample = samples,
Fraction = as.numeric(sub("Fraction(\\d+)_Rep\\d", "\\1", samples)),
Batch = sub("Fraction\\d+_(Rep\\d)", "\\1", samples)
)
# Modelle mit Dummy-Group
mod  <- model.matrix(~ Group, data = sampleInfo)
mod0 <- model.matrix(~ 1, data = sampleInfo)  # nur Intercept
sva_res <- sva(exprs_matrix, mod, mod0)
# Du kannst dann Surrogat-Variablen als Kovariaten in limma verwenden:
mod_sv <- cbind(mod, sva_res$sv)
fit <- lmFit(exprs_matrix, mod_sv)
fit <- eBayes(fit)
corrected <- expression_matrix - residuals + rowMeans(expression_matrix)
# Angenommen das hier sind deine Spaltennamen
samples <- colnames(final_smoothed_ctrl_df)[-1]  # -1 entfernt "Protein"
# sampleInfo automatisch extrahieren
sampleInfo <- data.frame(
Sample = samples,
Fraction = as.numeric(sub("Fraction(\\d+)_Rep\\d", "\\1", samples)),
Batch = sub("Fraction\\d+_(Rep\\d)", "\\1", samples)
)
sampleInfo$Group <- 1
# Modelle mit Dummy-Group
mod  <- model.matrix(~ Group, data = sampleInfo)
mod0 <- model.matrix(~ 1, data = sampleInfo)  # nur Intercept
sva_res <- sva(exprs_matrix, mod, mod0)
# Du kannst dann Surrogat-Variablen als Kovariaten in limma verwenden:
mod_sv <- cbind(mod, sva_res$sv)
fit <- lmFit(exprs_matrix, mod_sv)
fit <- eBayes(fit)
corrected <- expression_matrix - residuals + rowMeans(expression_matrix)
#Boxplot
boxplot(corrected, las = 2, main = "Expression nach SVA-Korrektur", col = as.factor(sample_info$Batch))
# Angenommen das hier sind deine Spaltennamen
samples <- colnames(final_smoothed_ctrl_df)[-1]  # -1 entfernt "Protein"
# sampleInfo automatisch extrahieren
sampleInfo <- data.frame(
Sample = samples,
Fraction = as.numeric(sub("Fraction(\\d+)_Rep\\d", "\\1", samples)),
Batch = sub("Fraction\\d+_(Rep\\d)", "\\1", samples)
)
sampleInfo$Group <- 1
# Modelle mit Dummy-Group
mod  <- model.matrix(~ Group, data = sampleInfo)
mod0 <- model.matrix(~ 1, data = sampleInfo)  # nur Intercept
sva_res <- sva(exprs_matrix, mod, mod0)
# Du kannst dann Surrogat-Variablen als Kovariaten in limma verwenden:
mod_sv <- cbind(mod, sva_res$sv)
fit <- lmFit(exprs_matrix, mod_sv)
fit <- eBayes(fit)
corrected <- expression_matrix - residuals + rowMeans(expression_matrix)
# Modelle mit Dummy-Group
library(sva)
mod  <- model.matrix(~ Group, data = sampleInfo)
mod0 <- model.matrix(~ 1, data = sampleInfo)  # nur Intercept
sva_res <- sva(exprs_matrix, mod, mod0)
# Du kannst dann Surrogat-Variablen als Kovariaten in limma verwenden:
mod_sv <- cbind(mod, sva_res$sv)
fit <- lmFit(exprs_matrix, mod_sv)
fit <- eBayes(fit)
corrected <- expression_matrix - residuals + rowMeans(expression_matrix)
# Modelle mit Dummy-Group
library(sva)
library(limma)
mod  <- model.matrix(~ Group, data = sampleInfo)
mod0 <- model.matrix(~ 1, data = sampleInfo)  # nur Intercept
sva_res <- sva(exprs_matrix, mod, mod0)
# Du kannst dann Surrogat-Variablen als Kovariaten in limma verwenden:
mod_sv <- cbind(mod, sva_res$sv)
fit <- lmFit(exprs_matrix, mod_sv)
fit <- eBayes(fit)
corrected <- expression_matrix - residuals + rowMeans(expression_matrix)
# Modelle mit Dummy-Group
library(sva)
library(limma)
mod  <- model.matrix(~ Group, data = sampleInfo)
mod0 <- model.matrix(~ 1, data = sampleInfo)  # nur Intercept
sva_res <- sva(exprs_matrix, mod, mod0)
# Du kannst dann Surrogat-Variablen als Kovariaten in limma verwenden:
mod_sv <- cbind(mod, sva_res$sv)
fit <- lmFit(exprs_matrix, mod_sv)
fit <- eBayes(fit)
corrected <- expression_matrix - residuals + rowMeans(expression_matrix)
# Modelle mit Dummy-Group
BiocManager::install(c("sva", "limma", "genefilter"))
library(sva)
library(limma)
mod  <- model.matrix(~ Group, data = sampleInfo)
mod0 <- model.matrix(~ 1, data = sampleInfo)  # nur Intercept
sva_res <- sva(exprs_matrix, mod, mod0)
# Du kannst dann Surrogat-Variablen als Kovariaten in limma verwenden:
mod_sv <- cbind(mod, sva_res$sv)
fit <- lmFit(exprs_matrix, mod_sv)
fit <- eBayes(fit)
corrected <- expression_matrix - residuals + rowMeans(expression_matrix)
a
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("sva")
yes
Yes
no
if (!require("BiocManager", quietly = TRUE))
install.packages("BiocManager")
BiocManager::install("sva")
a
# Modelle mit Dummy-Group
library(sva)
library(limma)
mod  <- model.matrix(~ Group, data = sampleInfo)
mod0 <- model.matrix(~ 1, data = sampleInfo)  # nur Intercept
sva_res <- sva(exprs_matrix, mod, mod0)
# Du kannst dann Surrogat-Variablen als Kovariaten in limma verwenden:
mod_sv <- cbind(mod, sva_res$sv)
fit <- lmFit(exprs_matrix, mod_sv)
fit <- eBayes(fit)
corrected <- expression_matrix - residuals + rowMeans(expression_matrix)
df_exprs <- read.csv(sampleInfo, row.names = 1)
exprs_matrix <- as.matrix(sampleInfo)
class(sampleInfo)
head(sampleInfo)
# Erstelle Design-Matrix
mod <- model.matrix(~ fraction + replicate, data = sampleInfo)
mod0 <- model.matrix(~ 1, data = sampleInfo)
# SVA
library(sva)
sva_res <- sva(expression_matrix, mod, mod0)
# Design mit SVs erweitern
mod_sv <- cbind(mod, sva_res$sv)
Beispiel: sampleInfo vorbereiten
sampleInfo$replicate <- as.factor(sampleInfo$replicate)
# Beispiel: sampleInfo vorbereiten
sampleInfo$replicate <- as.factor(sampleInfo$replicate)
colnames(final_smoothed_ctrl_df)
library(sva)
# 1) Expressionsmatrix (ohne Protein-Spalte)
expression_matrix <- as.matrix(final_smoothed_ctrl_df[, -1])
rownames(expression_matrix) <- final_smoothed_ctrl_df$Protein
# 2) Metadaten (sampleInfo) aus Spaltennamen erzeugen
# Spaltennamen sehen aus wie "Fraction1_Rep1", also splitten wir danach
samples <- colnames(expression_matrix)
library(stringr)
# Extract fraction and replicate info
fraction <- str_extract(samples, "Fraction\\d+")
replicate <- str_extract(samples, "Rep\\d+")
# sampleInfo DataFrame erstellen
sampleInfo <- data.frame(
fraction = factor(fraction),
replicate = factor(replicate)
)
# 3) Designmatrix für das Modell
mod <- model.matrix(~ fraction + replicate, data = sampleInfo)
mod0 <- model.matrix(~ 1, data = sampleInfo)  # Nullmodell
# 4) SVA durchführen
sva_res <- sva(expression_matrix, mod, mod0)
# 5) Designmatrix mit Surrogate Variablen erweitern
mod_sv <- cbind(mod, sva_res$sv)
# 6) Batch Effekt entfernen mit ComBat (optional, falls Batch bekannt)
# Hier Beispiel, falls du "batch" hast:
# batch <- sampleInfo$batch_variable
# expression_corrected <- ComBat(dat=expression_matrix, batch=batch, mod=mod)
# 7) Alternative: Surrogate Variablen in Analyse einbauen (mod_sv)
# Beispiel: Regression ohne Batch-Effekt (mit SVA)
# Linear model fitten, um den korrigierten Datensatz zu bekommen (optional)
library(limma)
fit <- lmFit(expression_matrix, mod_sv)
fit <- eBayes(fit)
corrected_expr <- residuals(fit, expression_matrix)
# corrected_expr enthält die Daten ohne die Effekte, die in mod_sv erklärt werden
# Batch-Vektor: z. B. basierend auf 'Rep' in den Spaltennamen
batch <- factor(str_extract(colnames(expression_matrix), "Rep\\d+"))
# Farben je Batch
batch_levels <- levels(batch)
batch_colors <- rainbow(length(batch_levels))
names(batch_colors) <- batch_levels
colors <- batch_colors[batch]
# 1. Boxplot vor Korrektur
boxplot(expression_matrix,
main = "Expression vor Korrektur (Replicate gefärbt)",
ylab = "Expression",
xlab = "Samples",
las = 2,
col = colors,
outline = FALSE,
cex.axis = 0.6)
# 2. Boxplot nach SVA-Korrektur (z. B. residuals oder sva-adjusted)
boxplot(corrected_expr,
main = "Expression nach SVA-Korrektur (Replicate gefärbt)",
ylab = "Expression",
xlab = "Samples",
las = 2,
col = colors,
outline = FALSE,
cex.axis = 0.6)
# 3. Legende
legend("topright",
legend = names(batch_colors),
fill = batch_colors,
title = "Replicate")
# Lade benötigte Libraries
library(sva)
library(stringr)
library(limma)
# 1) Expressionsmatrix (ohne Protein-Spalte)
expression_matrix <- as.matrix(final_smoothed_ctrl_df[, -1])
rownames(expression_matrix) <- final_smoothed_ctrl_df$Protein
# 2) Metadaten (sampleInfo) aus Spaltennamen erzeugen
samples <- colnames(expression_matrix)
# Extrahiere "Fraction" und "Replicate" Informationen aus Spaltennamen
fraction <- str_extract(samples, "Fraction\\d+")
replicate <- str_extract(samples, "Rep\\d+")
# sampleInfo DataFrame erstellen
sampleInfo <- data.frame(
fraction = factor(fraction),
replicate = factor(replicate)
)
# 3) Designmatrix für das Modell erstellen
mod <- model.matrix(~ fraction + replicate, data = sampleInfo)
mod0 <- model.matrix(~ 1, data = sampleInfo)  # Nullmodell ohne Prädiktoren
# 4) SVA durchführen
sva_res <- sva(expression_matrix, mod, mod0)
# 5) Designmatrix um die gefundenen Surrogate Variablen (SVs) erweitern
mod_sv <- cbind(mod, sva_res$sv)
# 6) OPTIONAL: Wenn du einen bekannten Batch hast, kannst du alternativ ComBat verwenden
# Beispiel (nur wenn du 'batch' hast):
# batch <- sampleInfo$batch_variable
# expression_corrected <- ComBat(dat = expression_matrix, batch = batch, mod = mod)
# 7) Korrektur mit Surrogate Variablen durch lineare Regression (empfohlen bei unbekanntem Batch)
# Fit des linearen Modells mit Surrogate Variablen
fit <- lmFit(expression_matrix, mod_sv)
fit <- eBayes(fit)
# Residuen extrahieren = korrigierter Datensatz ohne die erklärten Effekte (fraction + replicate + SVs)
corrected_expr <- residuals(fit, expression_matrix)
# 'corrected_expr' enthält die bereinigten Expressionswerte
# Batch-Vektor: z. B. basierend auf 'Rep' in den Spaltennamen
batch <- factor(str_extract(colnames(expression_matrix), "Rep\\d+"))
# Farben je Batch
batch_levels <- levels(batch)
batch_colors <- rainbow(length(batch_levels))
names(batch_colors) <- batch_levels
colors <- batch_colors[batch]
# 1. Boxplot vor Korrektur
boxplot(expression_matrix,
main = "Expression vor Korrektur (Replicate gefärbt)",
ylab = "Expression",
xlab = "Samples",
las = 2,
col = colors,
outline = FALSE,
cex.axis = 0.6)
# 2. Boxplot nach SVA-Korrektur (z. B. residuals oder sva-adjusted)
boxplot(corrected_expr,
main = "Expression nach SVA-Korrektur (Replicate gefärbt)",
ylab = "Expression",
xlab = "Samples",
las = 2,
col = colors,
outline = FALSE,
cex.axis = 0.6)
# 3. Legende
legend("topright",
legend = names(batch_colors),
fill = batch_colors,
title = "Replicate")
# 1) PCA vorbereiten
pca_before <- prcomp(t(expression_matrix), scale. = TRUE)
pca_after  <- prcomp(t(corrected_expr), scale. = TRUE)
# 2) Batch-Zuordnung erneut für Farben
sample_names <- colnames(expression_matrix)
batch <- sub(".*_(Rep\\d)", "\\1", sample_names)
batch <- factor(batch, levels = c("Rep1", "Rep2", "Rep3"))
# 3) Farben definieren für die Replikate
batch_colors <- rainbow(length(levels(batch)))
# 4) PCA-Plot: nebeneinander
par(mfrow = c(1, 2))  # Zwei Plots nebeneinander
# --- PCA vor Korrektur ---
plot(pca_before$x[, 1:2],
col = batch_colors[batch],
pch = 19,
main = "PCA vor Batch-Korrektur",
xlab = "PC1", ylab = "PC2")
legend("topright", legend = levels(batch), col = batch_colors, pch = 19)
# --- PCA nach Korrektur ---
plot(pca_after$x[, 1:2],
col = batch_colors[batch],
pch = 19,
main = "PCA nach SVA-Korrektur",
xlab = "PC1", ylab = "PC2")
legend("topright", legend = levels(batch), col = batch_colors, pch = 19)
# 5) Layout zurücksetzen
par(mfrow = c(1, 1))
# 1) Falls noch nicht installiert:
# install.packages("pheatmap")
library(pheatmap)
# 2) Hilfsfunktion: Top-N variabelste Proteine auswählen
select_top_var <- function(mat, top_n = 100) {
vars <- apply(mat, 1, var)
mat[order(vars, decreasing = TRUE)[1:top_n], ]
}
# 3) Top 100 variabelsten Proteine extrahieren
heat_before <- select_top_var(expression_matrix, 100)
heat_after  <- select_top_var(corrected_expr, 100)
# 4) Spaltenannotation: Replikate als Batch
annotation_col <- data.frame(Batch = batch)
rownames(annotation_col) <- colnames(expression_matrix)
# 5) Heatmaps zeichnen (jeweils mit Annotation)
# Hinweis: pheatmap unterstützt kein par(mfrow), daher separate Plots empfohlen
# --- Heatmap vor Korrektur ---
pheatmap(heat_before,
main = "Heatmap vor Batch-Korrektur",
annotation_col = annotation_col,
show_rownames = FALSE,
cluster_cols = TRUE,
fontsize_col = 6)
# --- Heatmap nach Korrektur ---
pheatmap(heat_after,
main = "Heatmap nach SVA-Korrektur",
annotation_col = annotation_col,
show_rownames = FALSE,
cluster_cols = TRUE,
fontsize_col = 6)
library(limma)
# 1. Matrix mit Expressionswerten extrahieren (ohne Protein-Spalte)
expr_matrix <- as.matrix(final_smoothed_ctrl_df[, -1])
# 2. Sample-Namen extrahieren
sample_names <- colnames(expr_matrix)
# 3. Batch-Labels aus Sample-Namen ziehen (Rep1, Rep2, Rep3)
batch <- sub(".*_(Rep\\d)", "\\1", sample_names)
batch <- factor(batch, levels = c("Rep1", "Rep2", "Rep3"))
# 4. Log2-Transformation (falls nötig, empfohlen wegen Skalenproblem)
expr_matrix_log <- log2(expr_matrix + 1)
# 5. Batch-Korrektur mit limma
expr_corrected <- removeBatchEffect(expr_matrix_log, batch = batch)
# 5. Boxplot zeichnen vor korrektur
boxplot(expr_matrix,
main = "Expression vor Korrektur (Batch gefärbt)",
ylab = "Expression",
xlab = "Samples",
las = 2,                      # X-Achse: senkrechte Labels
col = colors,
outline = FALSE,
cex.axis = 0.6)              # kleinere Achsenbeschriftung
# Boxplot nach Korrektur
boxplot(expr_corrected,
main = "Expression nach Korrektur (Batch gefärbt)",
ylab = "Expression",
xlab = "Samples",
las = 2,                      # X-Achse: senkrechte Labels
col = colors,
outline = FALSE,
cex.axis = 0.6)              # kleinere Achsenbeschriftung
# 6. Legende hinzufügen
legend("topright",
legend = names(batch_colors),
fill = batch_colors,
title = "Batch")
# PCA-Analyse vorbereiten
pca_before <- prcomp(t(expr_matrix), scale. = TRUE)
pca_after  <- prcomp(t(expr_corrected), scale. = TRUE)
# Batch-Zuordnung erneut für Farben
# 2. Sample-Namen extrahieren
sample_names <- colnames(expr_matrix)
# 3. Batch-Labels aus Sample-Namen ziehen (Rep1, Rep2, Rep3)
batch <- sub(".*_(Rep\\d)", "\\1", sample_names)
batch <- factor(batch, levels = c("Rep1", "Rep2", "Rep3"))
# Plot nebeneinander
par(mfrow = c(1, 2))
# PCA vor Korrektur
plot(pca_before$x[, 1:2],
col = rainbow(length(levels(batch)))[batch],
pch = 19,
main = "PCA vor Batch-Korrektur")
legend("topright", legend = levels(batch), col = rainbow(length(levels(batch))), pch = 19)
# PCA nach Korrektur
plot(pca_after$x[, 1:2],
col = rainbow(length(levels(batch)))[batch],
pch = 19,
main = "PCA nach Batch-Korrektur")
legend("topright", legend = levels(batch), col = rainbow(length(levels(batch))), pch = 19)
# Reset Layout
par(mfrow = c(1, 1))
# Optional: Wenn du pheatmap noch nicht hast
install.packages("pheatmap")
library(pheatmap)
# Auswahl einer Teilmenge der Proteine (z. B. Top 100 variabelsten)
select_top_var <- function(mat, top_n = 100) {
vars <- apply(mat, 1, var)
mat[order(vars, decreasing = TRUE)[1:top_n], ]
}
# Top 100 Gene mit höchster Varianz (vorher/nachher)
heat_before <- select_top_var(expr_matrix, 100)
heat_after  <- select_top_var(expr_corrected, 100)
# Spaltenannotation nach Batch
annotation_col <- data.frame(Batch = batch)
rownames(annotation_col) <- colnames(expr_matrix)
# Zwei Heatmaps nebeneinander
par(mfrow = c(1, 2))
pheatmap(heat_before,
main = "Heatmap vor Batch-Korrektur",
annotation_col = annotation_col,
show_rownames = FALSE,
cluster_cols = TRUE)
pheatmap(heat_after,
main = "Heatmap nach Batch-Korrektur",
annotation_col = annotation_col,
show_rownames = FALSE,
cluster_cols = TRUE)
# Reset Layout
par(mfrow = c(1, 1))
install.packages("pheatmap")
